From Coq Require Import List.
Import ListNotations.
From Equations Require Import Equations.
Require Import Coq.Program.Equality.
From Hammer Require Import Tactics.
From AAC_tactics Require Import AAC.
From AAC_tactics Require Import Instances.
Import Instances.Lists.

From Deques.color Require Import GYOR.
From Deques.deque Require Import deque.
From Deques.cadeque Require Import types models.

(* The [app] function and the singleton list are made opaque. *)
Opaque app.
Definition singleton {A : Type} (x : A) : list A := [x].
Opaque singleton.

(* Hint databases of rewrites to be used when trying to automatically resolve
   obligations on lists generated by [Equations]. *)
#[export] Hint Rewrite <-app_assoc : rassoc.
#[export] Hint Rewrite app_assoc : lassoc.

#[export] Hint Rewrite app_nil_r : rlist.
#[export] Hint Rewrite app_nil_l : rlist.
#[export] Hint Rewrite map_app : rlist.
#[export] Hint Rewrite concat_app : rlist.

(* NB: adding [correct_deque_cmseq] as a general rewrite rule would loop,
   because [deque_seq] is simply an instance of [deque_cmseq]. Instead, adding
   the specialized rewrite rule below is enough. *)
Lemma correct_deque_cmseq_stored
  [A lt n] (d : deque (stored A lt) n) :
  deque_cmseq (@stored_seq) d = concat (map (stored_seq) (deque_seq d)).
Proof.
  apply correct_deque_cmseq.
Qed.

#[export] Hint Rewrite correct_deque_cmseq_stored : rlist.

(* Notation for dependent types hiding the property on [x]. *)
Notation "? x" := (@exist _ _ x _) (at level 100).

(* Setting the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Pushes on a left node. *)
Equations push_left_node {A l a C}
  (st : stored A l)
  (n : node A l a left C) :
  { n' : node A l a left C |
    forall (l : list A),
      node_seq n' l = stored_seq st ++ node_seq n l } :=
push_left_node st (Left GN p s) with deque.push st p => {
  | ? p' := ? Left GN p' s };
push_left_node st (Left YN p s) with deque.push st p => {
  | ? p' := ? Left YN p' s };
push_left_node st (Left ON p s) with deque.push st p => {
  | ? p' := ? Left ON p' s };
push_left_node st (Left RN p s) with deque.push st p => {
  | ? p' := ? Left RN p' s };
push_left_node st (Left EN p s) with deque.push st p => {
  | ? p' := ? Left EN p' s }.

(* Injects on a right node. *)
Equations inject_right_node {A l a C}
  (n : node A l a right C)
  (st : stored A l) :
  { n' : node A l a right C |
    forall (l : list A),
      node_seq n' l = node_seq n l ++ stored_seq st } :=
inject_right_node (Right GN p s) st with deque.inject s st => {
  | ? s' := ? Right GN p s' };
inject_right_node (Right YN p s) st with deque.inject s st => {
  | ? s' := ? Right YN p s' };
inject_right_node (Right ON p s) st with deque.inject s st => {
  | ? s' := ? Right ON p s' };
inject_right_node (Right RN p s) st with deque.inject s st => {
  | ? s' := ? Right RN p s' };
inject_right_node (Right EN p s) st with deque.inject s st => {
  | ? s' := ? Right EN p s' }.

(* Pushes on an only node. *)
Equations push_only_node {A l a C}
  (st : stored A l)
  (n : node A l a only C) :
  { n' : node A l a only C |
    forall (l : list A),
      node_seq n' l = stored_seq st ++ node_seq n l } :=
push_only_node st (Only GN p s) with deque.push st p => {
  | ? p' := ? Only GN p' s };
push_only_node st (Only YN p s) with deque.push st p => {
  | ? p' := ? Only YN p' s };
push_only_node st (Only ON p s) with deque.push st p => {
  | ? p' := ? Only ON p' s };
push_only_node st (Only RN p s) with deque.push st p => {
  | ? p' := ? Only RN p' s };
push_only_node st (Only_end p) with deque.push st p => {
  | ? p' := ? Only_end p' }.

(* Injects on an only node. *)
Equations inject_only_node {A l a C}
  (n : node A l a only C)
  (st : stored A l) :
  { n' : node A l a only C |
    forall (l : list A),
      node_seq n' l = node_seq n l ++ stored_seq st } :=
inject_only_node (Only GN p s) st with deque.inject s st => {
  | ? s' := ? Only GN p s' };
inject_only_node (Only YN p s) st with deque.inject s st => {
  | ? s' := ? Only YN p s' };
inject_only_node (Only ON p s) st with deque.inject s st => {
  | ? s' := ? Only ON p s' };
inject_only_node (Only RN p s) st with deque.inject s st => {
  | ? s' := ? Only RN p s' };
inject_only_node (Only_end p) st with deque.inject p st => {
  | ? p' := ? Only_end p' }.

(* Pushes on a left packet. *)
Equations push_left_packet {A hl tl a C}
  (st : stored A hl)
  (pkt : packet A hl tl a left C) :
  { pkt' : packet A hl tl a left C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq st ++ packet_seq pkt l } :=
push_left_packet st (Packet Hole tl) with push_left_node st tl => {
  | ? tl' := ? Packet Hole tl' };
push_left_packet st (Packet (Single_child hd bd) tl)
  with push_left_node st hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_left_packet st (Packet (Pair_yellow hd bd cr) tl)
  with push_left_node st hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_left_packet st (Packet (Pair_orange hd cl bd) tl)
  with push_left_node st hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on a right packet. *)
Equations inject_right_packet {A hl tl a C}
  (pkt : packet A hl tl a right C)
  (st : stored A hl) :
  { pkt' : packet A hl tl a right C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq st } :=
inject_right_packet (Packet Hole tl) st with inject_right_node tl st => {
  | ? tl' := ? Packet Hole tl' };
inject_right_packet (Packet (Single_child hd bd) tl) st
  with inject_right_node hd st => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_right_packet (Packet (Pair_yellow hd bd cr) tl) st
  with inject_right_node hd st => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_right_packet (Packet (Pair_orange hd cl bd) tl) st
  with inject_right_node hd st => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Pushes on an only packet. *)
Equations push_only_packet {A hl tl a C}
  (st : stored A hl)
  (pkt : packet A hl tl a only C) :
  { pkt' : packet A hl tl a only C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq st ++ packet_seq pkt l } :=
push_only_packet st (Packet Hole tl) with push_only_node st tl => {
  | ? tl' := ? Packet Hole tl' };
push_only_packet st (Packet (Single_child hd bd) tl)
  with push_only_node st hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_only_packet st (Packet (Pair_yellow hd bd cr) tl)
  with push_only_node st hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_only_packet st (Packet (Pair_orange hd cl bd) tl)
  with push_only_node st hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on an only packet. *)
Equations inject_only_packet {A hl tl a C}
  (pkt : packet A hl tl a only C)
  (st : stored A hl) :
  { pkt' : packet A hl tl a only C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq st } :=
inject_only_packet (Packet Hole tl) st with inject_only_node tl st => {
  | ? tl' := ? Packet Hole tl' };
inject_only_packet (Packet (Single_child hd bd) tl) st
  with inject_only_node hd st => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_only_packet (Packet (Pair_yellow hd bd cr) tl) st
  with inject_only_node hd st => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_only_packet (Packet (Pair_orange hd cl bd) tl) st
  with inject_only_node hd st => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Returns an only node containing one element. *)
Equations single_node {A l}
  (st : stored A l) :
  { n : node A l 0 only green |
    forall (l : list A), node_seq n l = stored_seq st } :=
single_node st with deque.single st => { | ? p := ? Only_end p }.

(* Returns a packet containing one element. *)
Equations single_packet {A l}
  (st : stored A l) :
  { pkt : packet A l (S l) 0 only green |
    forall (l : list A), packet_seq pkt l = stored_seq st } :=
single_packet st with single_node st => { | ? tl := ? Packet Hole tl }.

(* Returns a chain containing one element. *)
Equations single_chain {A l}
  (st : stored A l) :
  { c : chain A l single only green green |
    chain_seq c = stored_seq st } :=
single_chain st with single_packet st => {
  | ? pkt := ? Single G pkt Empty }.

(* UIP is needed to simplify chains with the same left and right colors. *)
Set Equations With UIP.

(* Pushes on a left chain. *)
Equations push_left_chain {A l C}
  (st : stored A l)
  (c : chain A l single left C C) :
  { c' : chain A l single left C C |
    chain_seq c' = stored_seq st ++ chain_seq c } :=
push_left_chain st (Single reg pkt c)
  with push_left_packet st pkt => { | ? pkt' := ? Single reg pkt' c }.

(* Injects on a right chain. *)
Equations inject_right_chain {A l C}
  (c : chain A l single right C C)
  (st : stored A l) :
  { c' : chain A l single right C C |
    chain_seq c' = chain_seq c ++ stored_seq st } :=
inject_right_chain (Single reg pkt c) st
  with inject_right_packet pkt st => { | ? pkt' := ? Single reg pkt' c }.

(* Pushse on a non-empty only chain. *)
Equations push_ne_chain {A l a lC rC}
  (st : stored A l)
  (c : chain A l (S a) only lC rC) :
  { c' : chain A l (S a) only lC rC |
    chain_seq c' = stored_seq st ++ chain_seq c } :=
push_ne_chain st (Single reg pkt c) with push_only_packet st pkt => {
  | ? pkt' := ? Single reg pkt' c };
push_ne_chain st (Pair cl cr) with push_left_chain st cl => {
  | ? cl' := ? Pair cl' cr }.

(* Injects on a non-empty only chain. *)
Equations inject_ne_chain {A l a lC rC}
  (c : chain A l (S a) only lC rC)
  (st : stored A l) :
  { c' : chain A l (S a) only lC rC |
    chain_seq c' = chain_seq c ++ stored_seq st } :=
inject_ne_chain (Single reg pkt c) st with inject_only_packet pkt st => {
  | ? pkt' := ? Single reg pkt' c };
inject_ne_chain (Pair cl cr) st with inject_right_chain cr st => {
  | ? cr' := ? Pair cl cr' }.

(* Pushes on a semi-regular cadeque. *)
Equations semi_push {A l}
  (st : stored A l)
  (sd : semi_cadeque A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' = stored_seq st ++ semi_cadeque_seq sd } :=
semi_push st (Semi Empty) with single_chain st => {
  | ? c := ? Semi c };
semi_push st (Semi c) with push_ne_chain st c => {
  | ? c' := ? Semi c' }.

(* Injects on a semi-regular cadeque. *)
Equations semi_inject {A l}
  (sd : semi_cadeque A l)
  (st : stored A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' = semi_cadeque_seq sd ++ stored_seq st } :=
semi_inject (Semi Empty) st with single_chain st => {
  | ? c := ? Semi c };
semi_inject (Semi c) st with inject_ne_chain c st => {
  | ? c' := ? Semi c' }.

(* Pushes a vector on a semi-regular cadeque. *)
Equations push_vector {A l n}
  (v : vector (stored A l) n)
  (sd : semi_cadeque A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' =
      concat (map stored_seq (vector_seq v)) ++ semi_cadeque_seq sd } :=
push_vector V0 sd0 := ? sd0;
push_vector (V1 a1) sd0 with semi_push a1 sd0 => { | ? sd1 := ? sd1 };
push_vector (V2 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 := ? sd2 } };
push_vector (V3 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 := ? sd3 } } };
push_vector (V4 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 := ? sd4 } } } };
push_vector (V5 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 := ? sd5 } } } } };
push_vector (V6 a6 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 with semi_push a6 sd5 => { | ? sd6 := ? sd6 } } } } } }.

(* Injects a vector on a semi-regular cadeque. *)
Equations inject_vector {A l n}
  (sd : semi_cadeque A l)
  (v : vector (stored A l) n) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' =
      semi_cadeque_seq sd ++ concat (map stored_seq (vector_seq v)) } :=
inject_vector sd0 V0 := ? sd0;
inject_vector sd0 (V1 a1) with semi_inject sd0 a1 => { | ? sd1 := ? sd1 };
inject_vector sd0 (V2 a1 a2) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 := ? sd2 } };
inject_vector sd0 (V3 a1 a2 a3) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 := ? sd3 } } };
inject_vector sd0 (V4 a1 a2 a3 a4) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 := ? sd4 } } } };
inject_vector sd0 (V5 a1 a2 a3 a4 a5) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 := ? sd5 } } } } };
inject_vector sd0 (V6 a1 a2 a3 a4 a5 a6) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 with semi_inject sd5 a6 => { | ? sd6 := ? sd6 } } } } } }.

(* Returns the triple coloring rule associated to a yellow or orange node with
   one child. *)
Equations to_triple_coloring {A l k y o C} :
  node A l single k (Mix NoGreen y o NoRed) ->
  triple_coloring (Mix NoGreen y o NoRed) single C C C :=
to_triple_coloring (Only  YN _ _) := YT;
to_triple_coloring (Left  YN _ _) := YT;
to_triple_coloring (Right YN _ _) := YT;
to_triple_coloring (Only  ON _ _) := OST;
to_triple_coloring (Left  ON _ _) := OST;
to_triple_coloring (Right ON _ _) := OST.

(* Returns the triple representation of a non-empty only chain. *)
Equations triple_of_chain {A l k C}  (c : chain A l single k C C) :
  { t : triple A l k C | chain_seq c = triple_seq t } :=
triple_of_chain (Single G (Packet Hole tl) child) :=
  ? Triple GT tl child;
triple_of_chain (Single reg (Packet (Single_child hd bd) tl) rest) :=
  ? Triple (to_triple_coloring hd) hd (Single reg (Packet bd tl) rest);
triple_of_chain (Single reg (Packet (Pair_yellow hd bd cr) tl) rest) :=
  ? Triple YT hd (Pair (Single reg (Packet bd tl) rest) cr);
triple_of_chain (Single reg (Packet (Pair_orange hd cl bd) tl) rest) :=
  ? Triple OPT hd (Pair cl (Single reg (Packet bd tl) rest));
triple_of_chain (Single R (Packet Hole (Only RN p s)) child) :=
  ? Triple RT (Only RN p s) child;
triple_of_chain (Single R (Packet Hole (Left RN p s)) child) :=
  ? Triple RT (Left RN p s) child;
triple_of_chain (Single R (Packet Hole (Right RN p s)) child) :=
  ? Triple RT (Right RN p s) child.

(* Returns the non-empty only chain associated to a triple. *)
Equations chain_of_triple {A l k C} (t : triple A l k C) :
  { c : chain A l single k C C | chain_seq c = triple_seq t } :=
chain_of_triple (Triple GT hd child) :=
  ? Single G (Packet Hole hd) child;
chain_of_triple (Triple YT hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple YT hd (Pair (Single reg (Packet bd tl) rest) cr)) :=
  ? Single reg (Packet (Pair_yellow hd bd cr) tl) rest;
chain_of_triple (Triple OST hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple OPT hd (Pair cl (Single reg (Packet bd tl) rest))) :=
  ? Single reg (Packet (Pair_orange hd cl bd) tl) rest;
chain_of_triple (Triple RT hd child) :=
  ? Single R (Packet Hole hd) child.

(* Makes a left [left_right_triple] out of an only triple. *)
Equations left_of_only {A l C} (t : triple A l only C) :
  { lt : left_right_triple A l left C | lr_triple_seq lt = triple_seq t } :=
left_of_only (Triple GT (Only_end p) Empty) with deque.has7s p => {
  | ? inl v := ? Not_enough v;
  | ? inr (p1, st2, st1) :=
    ? Ok_lrt (Triple GT (Left EN p1 (st2, st1)) Empty) };
left_of_only (Triple tc (Only nc p s) child) with deque.eject2 s => {
  | ? (s1, st2, st1) with inject_ne_chain child (Small s1) => {
    | ? child1 := ? Ok_lrt (Triple tc (Left nc p (st2, st1)) child1) } }.

(* Makes a right [left_right_triple] out of an only triple. *)
Equations right_of_only {A l C} (t : triple A l only C) :
  { rt : left_right_triple A l right C | lr_triple_seq rt = triple_seq t } :=
right_of_only (Triple GT (Only_end s) Empty) with deque.has7p s => {
  | ? inl v := ? Not_enough v;
  | ? inr (st1, st2, s1) :=
    ? Ok_lrt (Triple GT (Right EN (st1, st2) s1) Empty) };
right_of_only (Triple tc (Only nc p s) child) with deque.pop2 p => {
  | ? (st1, st2, p1) with push_ne_chain (Small p1) child => {
    | ? child1 := ? Ok_lrt (Triple tc (Right nc (st1, st2) s) child1) } }.

(* Takes a suffix of at least one element and a right triple and returns a
   stored triple and a left suffix. *)
Equations stored_of_right {A l ql C}
  (sl : suffix A l (1 + ql))
  (tr : triple A l right C) :
  { '(stored, (st2, st1)) :
    stored A (S l) * (stored A l * stored A l) |
    stored_seq stored ++ stored_seq st2 ++ stored_seq st1 =
    suffix_seq sl ++ triple_seq tr } :=
stored_of_right sl (Triple tc (Right nc (st1, st2) sr) child)
  with deque.inject2 sl st1 st2 => {
    | ? p1 with deque.eject2 sr => {
      | ? (s1, st2', st1') := ? (Big p1 child s1, (st2', st1')) } }.

(* Takes a left triple and a prefix of at least one element and returns a
   right prefix and a stored triple. *)
Equations stored_of_left {A l qr C}
  (tl : triple A l left C)
  (pr : prefix A l (1 + qr)) :
  { '((st1, st2), stored) :
    (stored A l * stored A l) * stored A (S l) |
    stored_seq st1 ++ stored_seq st2 ++ stored_seq stored =
    triple_seq tl ++ prefix_seq pr } :=
stored_of_left (Triple tc (Left nc pl (st2, st1)) child) pr
  with deque.push2 st2 st1 pr => {
    | ? s1 with deque.pop2 pl => {
      | ? (st1', st2', p1) := ? ((st1', st2'), Big p1 child s1) } }.

(* Makes a left triple out of a pair of left and right triples. *)
Equations left_of_pair {A l lC rC}
  (tl : triple A l left lC) (tr : triple A l right rC) :
  { tl' : triple A l left lC |
    triple_seq tl' = triple_seq tl ++ triple_seq tr } :=
left_of_pair (Triple GT (Left EN p (st2, st1)) Empty) tr
  with deque.inject p st2, deque.single st1 => {
    | ? p1, ? s1 with stored_of_right s1 tr => {
      | ? (stored, s2) with single_chain stored => {
        | ? child := ? Triple OST (Left ON p1 s2) child } } };
left_of_pair (Triple tc (Left nc p (st2, st1)) child) tr
  with deque.pair st2 st1 => { | ? s with stored_of_right s tr => {
    | ? (stored, s1) with inject_ne_chain child stored => {
      | ? child1 := ? Triple tc (Left nc p s1) child1 } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Makes a right triple out of a pair of left and right triples. *)
Equations right_of_pair {A l lC rC}
  (tl : triple A l left lC) (tr : triple A l right rC) :
  { tr' : triple A l right rC |
    triple_seq tr' = triple_seq tl ++ triple_seq tr } :=
right_of_pair tl (Triple GT (Right EN (st1, st2) s) Empty)
  with deque.single st1, deque.push st2 s => {
    | ? p1, ? s1 with stored_of_left tl p1 => {
      | ? (p2, stored) with single_chain stored => {
        | ? child := ? Triple OST (Right ON p2 s1) child } } };
right_of_pair tl (Triple tc (Right nc (st1, st2) s) child)
  with deque.pair st1 st2 => { | ? p with stored_of_left tl p => {
    | ? (p1, stored) with push_ne_chain stored child => {
      | ? child1 := ? Triple tc (Right nc p1 s) child1 } } }.

(* Makes a left [left_right_triple] out of a chain. *)
Equations make_left {A l a lC rC} (c : chain A l a only lC rC) :
  { t : left_right_triple A l left lC | lr_triple_seq t = chain_seq c } :=
make_left Empty := ? Not_enough V0;
make_left (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with left_of_only t => { | ? t' := ? t' } };
make_left (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with left_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Makes a right [left_right_triple] out of a chain. *)
Equations make_right {A l a lC rC} (c : chain A l a only lC rC) :
  { t : left_right_triple A l right rC | lr_triple_seq t = chain_seq c } :=
make_right Empty := ? Not_enough V0;
make_right (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with right_of_only t => { | ? t' := ? t' } };
make_right (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with right_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Concatenates two semi-regular cadeques. *)
Equations semi_concat {A l} (s1 s2 : semi_cadeque A l) :
  { s3 : semi_cadeque A l |
    semi_cadeque_seq s3 = semi_cadeque_seq s1 ++ semi_cadeque_seq s2 } :=
semi_concat (Semi c1) (Semi c2) with make_left c1 => {
  | ? Not_enough v with push_vector v (Semi c2) => {
    | ? c3 := ? c3 };
  | ? Ok_lrt tl with make_right c2 => {
    | ? Not_enough v with inject_vector (Semi c1) v => {
      | ? c3 := ? c3 };
    | ? Ok_lrt tr with chain_of_triple tl, chain_of_triple tr => {
      | ? cl, ? cr := ? Semi (Pair cl cr) } } }.

(* Returns the orange triple coloring corresponding to the child chain. *)
Equations orange_tc {A l a rC} :
  chain A l (S a) only green rC ->
  triple_coloring orange (S a) green rC rC :=
orange_tc (Single _ _ _) := OST;
orange_tc (Pair _ _)     := OPT.

(* Pops from a green left triple. *)
Equations pop_left_green {A l} (tl : triple A l left green) :
  { '(st1, pt) : stored A l * partial_triple A l pair left |
    triple_seq tl = stored_seq st1 ++ pt_triple_seq pt } :=
pop_left_green (Triple GT (Left EN p (st6, st7)) Empty) with deque.pop p => {
  | ? (st1, p1) with deque.has5 p1 => {
    | ? inl (st2, st3, st4, st5) :=
      ? (st1, Six_elements (st2, st3, st4, st5, st6, st7));
    | ? inr p2 => ? (st1, Ok_pt (Triple GT (Left EN p2 (st6, st7)) Empty)) } };
pop_left_green (Triple GT (Left GN p s) child) with deque.pop p => {
  | ? (st1, p1) := ? (st1, Ok_pt (Triple YT (Left YN p1 s) child)) };
pop_left_green (Triple YT (Left YN p s) child)
  with deque.pop p => { | ? (st1, p1) :=
    ? (st1, Ok_pt (Triple (orange_tc child) (Left ON p1 s) child)) };
pop_left_green (Triple OST (Left ON p s) child)
  with deque.pop p => { | ? (st1, p1) :=
    ? (st1, Ok_pt (Triple RT (Left RN p1 s) child)) };
pop_left_green (Triple OPT (Left ON p s) child)
  with deque.pop p => { | ? (st1, p1) :=
    ? (st1, Ok_pt (Triple RT (Left RN p1 s) child)) }.

(* Ejects from a green right triple. *)
Equations eject_right_green {A l} (tr : triple A l right green) :
  { '(pt, st7) : partial_triple A l pair right * stored A l |
    triple_seq tr = pt_triple_seq pt ++ stored_seq st7 } :=
eject_right_green (Triple GT (Right EN (st1, st2) s) Empty)
  with deque.eject s => { | ? (s1, st7) with deque.has5 s1 => {
    | ? inl (st3, st4, st5, st6) :=
      ? (Six_elements (st1, st2, st3, st4, st5, st6), st7);
    | ? inr s2 => ? (Ok_pt (Triple GT (Right EN (st1, st2) s2) Empty), st7) } };
eject_right_green (Triple GT (Right GN p s) child) with deque.eject s => {
  | ? (s1, st7) := ? (Ok_pt (Triple YT (Right YN p s1) child), st7) };
eject_right_green (Triple YT (Right YN p s) child)
  with deque.eject s => { | ? (s1, st7) :=
    ? (Ok_pt (Triple (orange_tc child) (Right ON p s1) child), st7) };
eject_right_green (Triple OST (Right ON p s) child)
  with deque.eject s => { | ? (s1, st7) :=
    ? (Ok_pt (Triple RT (Right RN p s1) child), st7) };
eject_right_green (Triple OPT (Right ON p s) child)
  with deque.eject s => { | ? (s1, st7) :=
    ? (Ok_pt (Triple RT (Right RN p s1) child), st7) }.

(* Pops from a green only triple. *)
Equations pop_only_green {A l} (t : triple A l only green) :
  { '(st, pt) : stored A l * partial_triple A l single only |
    triple_seq t = stored_seq st ++ pt_triple_seq pt } :=
pop_only_green (Triple GT (Only_end p) Empty) with deque.pop p => {
  | ? (st, p1) with deque.has1 p1 => {
    | ? None := ? (st, Zero_element);
    | ? Some p2 := ? (st, Ok_pt (Triple GT (Only_end p2) Empty)) } };
pop_only_green (Triple GT (Only GN p s) child) with deque.pop p => {
  | ? (st, p1) := ? (st, Ok_pt (Triple YT (Only YN p1 s) child)) };
pop_only_green (Triple YT (Only YN p s) child) with deque.pop p => {
  | ? (st, p1) :=
    ? (st, Ok_pt (Triple (orange_tc child) (Only ON p1 s) child)) };
pop_only_green (Triple OST (Only ON p s) child) with deque.pop p => {
  | ? (st, p1) := ? (st, Ok_pt (Triple RT (Only RN p1 s) child)) };
pop_only_green (Triple OPT (Only ON p s) child) with deque.pop p => {
  | ? (st, p1) := ? (st, Ok_pt (Triple RT (Only RN p1 s) child)) }.

(* Ejects from a green only triple. *)
Equations eject_only_green {A l} (t : triple A l only green) :
  { '(pt, st) : partial_triple A l single only * stored A l |
    triple_seq t = pt_triple_seq pt ++ stored_seq st } :=
eject_only_green (Triple GT (Only_end s) Empty) with deque.eject s => {
  | ? (s1, st) with deque.has1 s1 => {
    | ? None := ? (Zero_element, st);
    | ? Some s2 := ? (Ok_pt (Triple GT (Only_end s2) Empty), st) } };
eject_only_green (Triple GT (Only GN p s) child) with deque.eject s => {
  | ? (s1, st) := ? (Ok_pt (Triple YT (Only YN p s1) child), st) };
eject_only_green (Triple YT (Only YN p s) child) with deque.eject s => {
  | ? (s1, st) :=
    ? (Ok_pt (Triple (orange_tc child) (Only ON p s1) child), st) };
eject_only_green (Triple OST (Only ON p s) child) with deque.eject s => {
  | ? (s1, st) := ? (Ok_pt (Triple RT (Only RN p s1) child), st) };
eject_only_green (Triple OPT (Only ON p s) child) with deque.eject s => {
  | ? (s1, st) := ? (Ok_pt (Triple RT (Only RN p s1) child), st) }.

(* Takes an green only triple and represent it as a sandwich. *)
Equations sandwich_only_green {A l} (t : triple A l only green) :
  { s : sandwich (stored A l) (partial_triple A l single only) |
    triple_seq t = sandwich_seq stored_seq pt_triple_seq s } :=
sandwich_only_green (Triple GT (Only_end p) Empty) with deque.pop p => {
  | ? (sta, p1) with deque.has1 p1 => {
    | ? None := ? Alone sta;
    | ? Some s with deque.eject s => {
      | ? (s1, stz) with deque.has1 s1 => {
        | ? None := ? Sandwich sta Zero_element stz;
        | ? Some b :=
          ? Sandwich sta (Ok_pt (Triple GT (Only_end b) Empty)) stz } } } };
sandwich_only_green (Triple GT (Only GN p s) child)
  with deque.pop p, deque.eject s => { | ? (sta, p1), ? (s1, stz) :=
    ? Sandwich sta (Ok_pt (Triple YT (Only YN p1 s1) child)) stz };
sandwich_only_green (Triple YT (Only YN p s) child)
  with deque.pop p, deque.eject s => { | ? (sta, p1), ? (s1, stz) :=
    ? Sandwich
        sta
        (Ok_pt (Triple (orange_tc child) (Only ON p1 s1) child))
        stz
  };
sandwich_only_green (Triple OST (Only ON p s) child)
  with deque.pop p, deque.eject s => { | ? (sta, p1), ? (s1, stz) :=
    ? Sandwich sta (Ok_pt (Triple RT (Only RN p1 s1) child)) stz };
sandwich_only_green (Triple OPT (Only ON p s) child)
  with deque.pop p, deque.eject s => { | ? (sta, p1), ? (s1, stz) :=
    ? Sandwich sta (Ok_pt (Triple RT (Only RN p1 s1) child)) stz }.

(* Adapts a node coloring to a prefix of 8 or more elements. *)
Equations adapt_to_prefix {qp qs q a C} :
  node_coloring qp qs a C -> node_coloring (3 + q) qs a C :=
adapt_to_prefix GN := GN;
adapt_to_prefix YN := YN;
adapt_to_prefix ON := ON;
adapt_to_prefix RN := RN;
adapt_to_prefix EN := EN.

(* Makes an only triple out of six elements and a right triple. *)
Equations only_of_right {A l C}
  (six : six_stored A l)
  (tr : triple A l right C) :
  { t : triple A l only C |
    triple_seq t = six_stored_seq six ++ triple_seq tr } :=
only_of_right (st1, st2, st3, st4, st5, st6)
              (Triple GT (Right EN (st7, st8) s) Empty)
    with deque.push2 st7 st8 s => {
      | ? s1 with deque.push6 st1 st2 st3 st4 st5 st6 s1 => {
        | ? s2 := ? Triple GT (Only_end s2) Empty } };
only_of_right (st1, st2, st3, st4, st5, st6)
              (Triple tc (Right nc (st7, st8) s) child)
  with deque.pair st7 st8 => {
    | ? p1 with deque.push6 st1 st2 st3 st4 st5 st6 p1 => {
      | ? p2 := ? Triple tc (Only (adapt_to_prefix nc) p2 s) child } }.

(* Adapts a node coloring to a suffix of 8 or more elements. *)
Equations adapt_to_suffix {qp qs q a C} :
  node_coloring qp qs a C -> node_coloring qp (3 + q) a C :=
adapt_to_suffix GN := GN;
adapt_to_suffix YN := YN;
adapt_to_suffix ON := ON;
adapt_to_suffix RN := RN;
adapt_to_suffix EN := EN.

(* Makes an only triple out of a left triple and six elements. *)
Equations only_of_left {A l C}
  (tl : triple A l left C)
  (six : six_stored A l) :
  { t : triple A l only C |
    triple_seq t = triple_seq tl ++ six_stored_seq six } :=
only_of_left (Triple GT (Left EN p (st8, st7)) Empty)
             (st6, st5, st4, st3, st2, st1)
    with deque.inject2 p st8 st7 => {
      | ? p1 with deque.inject6 p1 st6 st5 st4 st3 st2 st1 => {
        | ? p2 := ? Triple GT (Only_end p2) Empty } };
only_of_left (Triple tc (Left nc p (st8, st7)) child)
             (st6, st5, st4, st3, st2, st1)
  with deque.pair st8 st7 => {
    | ? s1 with deque.inject6 s1 st6 st5 st4 st3 st2 st1 => {
      | ? s2 := ? Triple tc (Only (adapt_to_suffix nc) p s2) child } }.

(* Pops from a green pair chain. *)
Equations pop_pair_green {A l}
  (c : chain A l pair only green green) :
  { '(st, sd) : stored A l * semi_cadeque A l |
    chain_seq c = stored_seq st ++ semi_cadeque_seq sd } :=
pop_pair_green (Pair cl cr) with triple_of_chain cl => {
  | ? tl with pop_left_green tl => {
    | ? (st, Six_elements six) with triple_of_chain cr => {
      | ? tr with only_of_right six tr => {
        | ? t with chain_of_triple t => {
          | ? c := ? (st, Semi c) } } };
    | ? (st, Ok_pt tl1) with chain_of_triple tl1 => {
      | ? cl1 := ? (st, Semi (Pair cl1 cr)) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Ejects from a green pair chain. *)
Equations eject_pair_green {A l}
  (c : chain A l pair only green green) :
  { '(sd, st) : semi_cadeque A l * stored A l |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq st } :=
eject_pair_green (Pair cl cr) with triple_of_chain cr => {
  | ? tr with eject_right_green tr => {
    | ? (Six_elements six, st) with triple_of_chain cl => {
      | ? tl with only_of_left tl six => {
        | ? t with chain_of_triple t => {
          | ? c := ? (Semi c, st) } } };
    | ? (Ok_pt tr1, st) with chain_of_triple tr1 => {
      | ? cr1 := ? (Semi (Pair cl cr1), st) } } }.

(* Takes a green pair chain and represent it as a sandwich. *)
Equations sandwich_pair_green {A l}
  (c : chain A l pair only green green) :
  { s : sandwich (stored A l) (semi_cadeque A l) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_pair_green (Pair cl cr)
  with triple_of_chain cl, triple_of_chain cr => {
    | ? tl, ? tr with pop_left_green tl, eject_right_green tr => {
      | ? (sta1, Six_elements (sta2, sta3, sta4, sta5, sta6, sta7)),
        ? (Six_elements (stz7, stz6, stz5, stz4, stz3, stz2), stz1)
        with deque.empty => {
          | ? b with deque.push6 sta2 sta3 sta4 sta5 sta6 sta7 b => {
            | ? b1 with deque.inject6 b1 stz7 stz6 stz5 stz4 stz3 stz2 => {
              | ? b2 :=
                ? Sandwich
                    sta1
                    (Semi (Single G (Packet Hole (Only_end b2)) Empty))
                    stz1
        } } };
      | ? (sta1, Six_elements six), ? (Ok_pt tr1, stz1)
        with only_of_right six tr1 => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich sta1 (Semi c) stz1 } };
      | ? (sta1, Ok_pt tl1), ? (Six_elements six, stz1)
        with only_of_left tl1 six => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich sta1 (Semi c) stz1 } };
      | ? (sta1, Ok_pt tl1), ? (Ok_pt tr1, stz1)
        with chain_of_triple tl1, chain_of_triple tr1 => {
          | ? cl1, ? cr1 :=
            ? Sandwich sta1 (Semi (Pair cl1 cr1)) stz1 } } }.

(* Pops from a non-empty green chain. *)
Equations pop_green {A l a} (c : chain A l (S a) only green green) :
  { '(st, sd) : stored A l * semi_cadeque A l |
    chain_seq c = stored_seq st ++ semi_cadeque_seq sd } :=
pop_green (a := 0) c with triple_of_chain c => {
  | ? t with pop_only_green t => {
    | ? (st, Zero_element) := ? (st, Semi Empty)
    | ? (st, Ok_pt t1) with chain_of_triple t1 => {
      | ? c1 := ? (st, Semi c1) } } };
pop_green (a := 1) c := pop_pair_green c.

(* Ejects from a non-empty green chain. *)
Equations eject_green {A l a} (c : chain A l (S a) only green green) :
  { '(sd, st) : semi_cadeque A l * stored A l |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq st } :=
eject_green (a := 0) c with triple_of_chain c => {
  | ? t with eject_only_green t => {
    | ? (Zero_element, st) := ? (Semi Empty, st);
    | ? (Ok_pt t1, st) with chain_of_triple t1 => {
      | ? c1 := ? (Semi c1, st) } } };
eject_green (a := 1) c := eject_pair_green c.

(* Takes a non-empty green chain and represent it as a sandwich. *)
Equations sandwich_green {A l a}
  (c : chain A l (S a) only green green) :
  { s : sandwich (stored A l) (semi_cadeque A l) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_green (a := 0) c with triple_of_chain c => {
  | ? t with sandwich_only_green t => {
    | ? Alone st := ? Alone st;
    | ? Sandwich sta Zero_element stz := ? Sandwich sta (Semi Empty) stz;
    | ? Sandwich sta (Ok_pt t1) stz with chain_of_triple t1 => {
      | ? c1 := ? Sandwich sta (Semi c1) stz } } };
sandwich_green (a := 1) c := sandwich_pair_green c.

(* Takes a prefix of at least 5 elements, a prefix of at least 3 elements and
   and a semi-regular cadeque of stored triples. Rearranges the elements of the
   second prefix to make the first one green (i.e. at least 8 elements). *)
Equations make_green_prefix {A l q qstored}
  (p : prefix A l (5 + q))
  (pstored : prefix A l (3 + qstored))
  (child : semi_cadeque A (S l)) :
  { '(pgreen, child') : green_buffer A l * semi_cadeque A (S l) |
    green_buffer_seq pgreen ++ semi_cadeque_seq child' =
    prefix_seq p ++ prefix_seq pstored ++ semi_cadeque_seq child } :=
make_green_prefix p pstored child with deque.has3p pstored => {
  | ? ((st1, st2, st3), inl v) with deque.inject3 p st1 st2 st3 => {
    | ? pgreen with deque.inject_vector pgreen v => {
      | ? pgreen1 := ? (Gbuf pgreen1, child) } };
  | ? ((st1, st2, st3), inr pstored1) with deque.inject3 p st1 st2 st3 => {
    | ? pgreen with semi_push (Small pstored1) child => {
      | ? child1 := ? (Gbuf pgreen, child1) } } }.

(* Takes a semi-regular cadeque of stored triples, a suffix of at least 3
   elements and a suffix of at least 5 elements. Rearranges the elements of
   the first suffix to make the second one green (i.e. at least 8 elements). *)
Equations make_green_suffix {A l q qstored}
  (child : semi_cadeque A (S l))
  (sstored : suffix A l (3 + qstored))
  (s : suffix A l (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S l) * green_buffer A l |
    semi_cadeque_seq child' ++ green_buffer_seq sgreen =
    semi_cadeque_seq child ++ suffix_seq sstored ++ suffix_seq s } :=
make_green_suffix child sstored s with deque.has3s sstored => {
  | ? (inl v, (st3, st2, st1)) with deque.push3 st3 st2 st1 s => {
    | ? sgreen with deque.push_vector v sgreen => {
      | ? sgreen1 := ? (child, Gbuf sgreen1) } };
  | ? (inr sstored1, (st3, st2, st1)) with deque.push3 st3 st2 st1 s => {
    | ? sgreen with semi_inject child (Small sstored1) => {
      | ? child1 := ? (child1, Gbuf sgreen) } } }.

(* Takes a stored triple and a semi-regular cadeque of stored triples. Extracts
   the prefix of the stored triple, the remaining elements and the semi
   regular cadeque form a new semi-regular cadeque. *)
Equations extract_prefix {A l}
  (stored : stored A (S l))
  (child : semi_cadeque A (S l)) :
  { '(pstored, child') : stored_buffer A l * semi_cadeque A (S l) |
    stored_buffer_seq pstored ++ semi_cadeque_seq child' =
    stored_seq stored ++ semi_cadeque_seq child } :=
extract_prefix (Small p) child := ? (Sbuf p, child);
extract_prefix (Big p schild s) child with semi_push (Small s) child => {
    | ? child1 with semi_concat (Semi schild) child1 => {
      | ? child2 := ? (Sbuf p, child2) } }.

(* Takes a semi-regular cadeque of stored triples and a stored triple. Extracs
   the suffix of the stored triple, the semi-regular cadeque and the remaining
   elements form a new semi-regular cadeque. *)
Equations extract_suffix {A l}
  (child : semi_cadeque A (S l))
  (stored : stored A (S l)) :
  { '(child', sstored) : semi_cadeque A (S l) * stored_buffer A l |
    semi_cadeque_seq child' ++ stored_buffer_seq sstored =
    semi_cadeque_seq child ++ stored_seq stored } :=
extract_suffix child (Small s) := ? (child, Sbuf s);
extract_suffix child (Big p schild s) with semi_inject child (Small p) => {
  | ? child1 with semi_concat child1 (Semi schild) => {
    | ? child2 := ? (child2, Sbuf s) } }.

(* Takes a prefix of at least 5 elements and a semi-regular cadeque of stored
   triples. Rearranges elements of the semi-regular cadeque to make the prefix
   green. *)
Equations ensure_green_prefix {A l q a}
  (p : prefix A l (5 + q))
  (child : chain A (S l) (S a) only green green) :
  { '(pgreen, child') : green_buffer A l * semi_cadeque A (S l) |
    prefix_seq p ++ chain_seq child =
    green_buffer_seq pgreen ++ semi_cadeque_seq child' } :=
ensure_green_prefix p child with pop_green child => {
  | ? (stored, child1) with extract_prefix stored child1 => {
    | ? (Sbuf pstored, child2) with make_green_prefix p pstored child2 => {
      | ? (pg, child3) := ? (pg, child3) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Takes a semi-regular cadeque of stored triples and a suffix of at least 5
   elements. Rearranges elements of the semi-regular cadeque to make the suffix
   green. *)
Equations ensure_green_suffix {A l q a}
  (child : chain A (S l) (S a) only green green)
  (s : suffix A l (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S l) * green_buffer A l |
    chain_seq child ++ suffix_seq s =
    semi_cadeque_seq child' ++ green_buffer_seq sgreen } :=
ensure_green_suffix child s with eject_green child => {
  | ? (child1, stored) with extract_suffix child1 stored => {
    | ? (child2, Sbuf sstored) with make_green_suffix child2 sstored s => {
      | ? (child3, sg) := ? (child3, sg) } } }.

(* Takes a body, a following red left node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_left {A hl tl hk a}
  (bd : body A hl tl hk left)
  (red : node A tl (S a) left red)
  (child : chain A (S tl) (S a) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_left bd (Left RN p s) child
  with ensure_green_prefix p child => {
    | ? (Gbuf p1, Semi Empty) :=
      ? Single G (Packet bd (Left EN p1 s)) Empty;
    | ? (Gbuf p1, Semi child1) :=
      ? Single G (Packet bd (Left GN p1 s)) child1 }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases.

   The [unfold Nat.add] tactic ensures that natural numbers that are equal
   are indeed type checked as equal, some additions interfer with the equality
   otherwise. *)
#[local] Obligation Tactic := try (cbn; unfold Nat.add; hauto db:rlist, rassoc).

(* Takes a body, a following red right node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_right {A hl tl hk a}
  (bd : body A hl tl hk right)
  (red : node A tl (S a) right red)
  (child : chain A (S tl) (S a) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_right bd (Right RN p s) child
  with ensure_green_suffix child s => {
    | ? (Semi Empty, Gbuf s1) :=
      ? Single G (Packet bd (Right EN p s1)) Empty;
    | ? (Semi child1, Gbuf s1) :=
      ? Single G (Packet bd (Right GN p s1)) child1 }.

(* Takes a body and a following green triple, and makes a green chain out of
   them. *)
Equations make_green_only {A hl tl hk qp qs}
  (bd : body A hl tl hk only)
  (p : prefix A tl (8 + qp))
  (child : semi_cadeque A (S tl))
  (s : prefix A tl (8 + qs)) :
  { c : chain A hl single hk green green |
    chain_seq c =
      body_seq bd (prefix_seq p ++ semi_cadeque_seq child ++ suffix_seq s) } :=
make_green_only bd p (Semi Empty) s with deque.has3p8 s => {
  | ? inl ((st1, st2, st3, st4, st5, st6, st7, st8), v)
    with deque.inject8 p st1 st2 st3 st4 st5 st6 st7 st8 => {
      | ? p1 with deque.inject_vector p1 v => {
        | ? p2 :=
          ? Single G (Packet bd (Only_end p2)) Empty } };
  | ? inr (small, s1) with single_chain (Small small) => {
    | ? child :=
      ? Single G (Packet bd (Only GN p s1)) child } };
make_green_only bd p (Semi child) s :=
  ? Single G (Packet bd (Only GN p s)) child.
Next Obligation. Qed.

(* Changing the default tactics for obligations to be [idtac].

   [hauto] is not used there because it takes too much time to compute, especially in cases where it cannot prove the result. *)
#[local] Obligation Tactic := idtac.

(* Takes a body, a following red only node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_only {A hl tl hk a}
  (bd : body A hl tl hk only)
  (red : node A tl (S a) only red)
  (child : chain A (S tl) (S a) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_only bd (Only RN p s) child
  with deque.has8 p, deque.has8 s => {
    | ? inl (sta1, sta2, sta3, sta4, sta5, vp),
      ? inl (stz5, stz4, stz3, stz2, stz1, vs) with sandwich_green child => {
      | ? Alone (Small b)
        with deque.push_5vector sta1 sta2 sta3 sta4 sta5 vp b => {
          | ? b1 with deque.inject_5vector b1 stz5 stz4 stz3 stz2 stz1 vs => {
            | ? b2 := ? Single G (Packet bd (Only_end b2)) Empty } };
      | ? Alone (Big pre1 child1 suf1)
        with deque.push_5vector sta1 sta2 sta3 sta4 sta5 vp pre1 => { | ? pre2
          with deque.inject_5vector suf1 stz5 stz4 stz3 stz2 stz1 vs => {
            | ? suf2 with make_green_only bd pre2 (Semi child1) suf2 => {
              | ? res := ? res } } };
      | ? Sandwich storedl child1 storedr
        with extract_prefix storedl child1 => { | ? (Sbuf pre1, child2)
          with extract_suffix child2 storedr => { | ? (child3, Sbuf suf1)
            with deque.push_5vector sta1 sta2 sta3 sta4 sta5 vp pre1 => {
              | ? pre2
            with deque.inject_5vector suf1 stz5 stz4 stz3 stz2 stz1 vs => {
              | ? suf2
                with make_green_only bd pre2 child3 suf2 => {
                  | ? res := ? res } } } } } };
    | ? inl _, ? inr suf1 with ensure_green_prefix p child => {
      | ? (Gbuf pre1, child1) with make_green_only bd pre1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inl _ with ensure_green_suffix child s => {
      | ? (child1, Gbuf suf1) with make_green_only bd pre1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inr suf1 :=
      ? Single G (Packet bd (Only GN pre1 suf1)) child }.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hp2 * Hp1 * Hres Hs2 Hs1 Hchild.
  do 2 rewrite correct_deque_cmseq_stored in *.
  rewrite Hp, Hs, Hres, Hp2, Hs2, Hchild.
  autorewrite with rlist rassoc.
  do 7 f_equal.
  (* XXX work around aac_rewrite bugs *)
  set (X := concat (map stored_seq (deque_seq suf1))) in *.
  aac_rewrite Hs1.
  subst X.
  set (X := concat (map stored_seq (deque_seq pre1))) in *.
  aac_rewrite Hp1.
  subst X.
  aac_reflexivity.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hres Hchild.
  do 2 rewrite correct_deque_cmseq_stored in *.
  rewrite Hres, Hs.
  rewrite app_assoc, <-Hchild.
  (* XXX: aac_rewrite <-Hchild. *)
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Takes any chain and makes it green. *)
Equations ensure_green {A l a k lC rC}
  (c : chain A l a k lC rC) :
  { c' : chain A l a k green green | chain_seq c = chain_seq c' } :=
ensure_green Empty := ? Empty;
ensure_green (Single G pkt c) := ? Single G pkt c;
ensure_green (Single R (Packet bd (Only RN p s)) c)
  with green_of_red_only bd (Only RN p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Left RN p s)) c)
  with green_of_red_left bd (Left RN p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Right RN p s)) c)
  with green_of_red_right bd (Right RN p s) c => { | ? c' := ? c' };
ensure_green (Pair cl cr) with ensure_green cl, ensure_green cr => {
  | ? cl', ? cr' := ? Pair cl' cr' }.

(* Regularizes a semi-regular cadeque. *)
Equations regularize {A} (sd : semi_cadeque A 0) :
  { d : cadeque A | cadeque_seq d = semi_cadeque_seq sd } :=
regularize (Semi c) with ensure_green c => { | ? c' := ? T c' }.
