From Coq Require Import List.
Import ListNotations.
From Equations Require Import Equations.
Require Import Coq.Program.Equality.
From Hammer Require Import Tactics.
From AAC_tactics Require Import AAC.
From AAC_tactics Require Import Instances.
Import Instances.Lists.

From Cadeque.color Require Import GYOR.
From Cadeque.cadeque Require Import buffer types models.

(* The [app] function and the singleton list are made opaque. *)
Opaque app.
Definition singleton {A : Type} (x : A) : list A := [x].
Opaque singleton.

(* Hint databases of rewrites to be used when trying to automatically resolve
   obligations on lists generated by [Equations]. *)
#[export] Hint Rewrite <-app_assoc : rassoc.
#[export] Hint Rewrite app_assoc : lassoc.

#[export] Hint Rewrite app_nil_r : rlist.
#[export] Hint Rewrite app_nil_l : rlist.
#[export] Hint Rewrite map_app : rlist.
#[export] Hint Rewrite concat_app : rlist.

#[export] Hint Rewrite buffer.correct_cmseq : rlist.

(* Notation for dependent types hiding the property on [x]. *)
Notation "? x" := (@exist _ _ x _) (at level 100).

(* Setting the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Pushes on a left node. *)
Equations push_left_node {A l ar C}
  (a1 : stored A l)
  (st : node A l ar left C) :
  { st' : node A l ar left C |
    forall (l : list A),
      node_seq st' l = stored_seq a1 ++ node_seq st l } :=
push_left_node a1 (Left GN p s) with buffer.push a1 p => {
  | ? p' := ? Left GN p' s };
push_left_node a1 (Left YN p s) with buffer.push a1 p => {
  | ? p' := ? Left YN p' s };
push_left_node a1 (Left ON p s) with buffer.push a1 p => {
  | ? p' := ? Left ON p' s };
push_left_node a1 (Left RN p s) with buffer.push a1 p => {
  | ? p' := ? Left RN p' s };
push_left_node a1 (Left EN p s) with buffer.push a1 p => {
  | ? p' := ? Left EN p' s }.

(* Injects on a right node. *)
Equations inject_right_node {A l ar C}
  (st : node A l ar right C)
  (a1 : stored A l) :
  { st' : node A l ar right C |
    forall (l : list A),
      node_seq st' l = node_seq st l ++ stored_seq a1 } :=
inject_right_node (Right GN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right GN p s' };
inject_right_node (Right YN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right YN p s' };
inject_right_node (Right ON p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right ON p s' };
inject_right_node (Right RN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right RN p s' };
inject_right_node (Right EN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right EN p s' }.

(* Pushes on an only node. *)
Equations push_only_node {A l ar C}
  (a1 : stored A l)
  (st : node A l ar only C) :
  { st' : node A l ar only C |
    forall (l : list A),
      node_seq st' l = stored_seq a1 ++ node_seq st l } :=
push_only_node a1 (Only GN p s) with buffer.push a1 p => {
  | ? p' := ? Only GN p' s };
push_only_node a1 (Only YN p s) with buffer.push a1 p => {
  | ? p' := ? Only YN p' s };
push_only_node a1 (Only ON p s) with buffer.push a1 p => {
  | ? p' := ? Only ON p' s };
push_only_node a1 (Only RN p s) with buffer.push a1 p => {
  | ? p' := ? Only RN p' s };
push_only_node a1 (Only_end p) with buffer.push a1 p => {
  | ? p' := ? Only_end p' }.

(* Injects on an only node. *)
Equations inject_only_node {A l ar C}
  (st : node A l ar only C)
  (a1 : stored A l) :
  { st' : node A l ar only C |
    forall (l : list A),
      node_seq st' l = node_seq st l ++ stored_seq a1 } :=
inject_only_node (Only GN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only GN p s' };
inject_only_node (Only YN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only YN p s' };
inject_only_node (Only ON p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only ON p s' };
inject_only_node (Only RN p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only RN p s' };
inject_only_node (Only_end p) a1 with buffer.inject p a1 => {
  | ? p' := ? Only_end p' }.

(* Pushes on a left packet. *)
Equations push_left_packet {A hl tl ar C}
  (a1 : stored A hl)
  (pkt : packet A hl tl ar left C) :
  { pkt' : packet A hl tl ar left C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq a1 ++ packet_seq pkt l } :=
push_left_packet a1 (Packet Hole tl) with push_left_node a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_left_packet a1 (Packet (Single_child hd bd) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_left_packet a1 (Packet (Pair_yellow hd bd cr) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_left_packet a1 (Packet (Pair_orange hd cl bd) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on a right packet. *)
Equations inject_right_packet {A hl tl ar C}
  (pkt : packet A hl tl ar right C)
  (a1 : stored A hl) :
  { pkt' : packet A hl tl ar right C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq a1 } :=
inject_right_packet (Packet Hole tl) a1 with inject_right_node tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_right_packet (Packet (Single_child hd bd) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_right_packet (Packet (Pair_yellow hd bd cr) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_right_packet (Packet (Pair_orange hd cl bd) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Pushes on an only packet. *)
Equations push_only_packet {A hl tl ar C}
  (a1 : stored A hl)
  (pkt : packet A hl tl ar only C) :
  { pkt' : packet A hl tl ar only C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq a1 ++ packet_seq pkt l } :=
push_only_packet a1 (Packet Hole tl) with push_only_node a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_only_packet a1 (Packet (Single_child hd bd) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_only_packet a1 (Packet (Pair_yellow hd bd cr) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_only_packet a1 (Packet (Pair_orange hd cl bd) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on an only packet. *)
Equations inject_only_packet {A hl tl ar C}
  (pkt : packet A hl tl ar only C)
  (a1 : stored A hl) :
  { pkt' : packet A hl tl ar only C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq a1 } :=
inject_only_packet (Packet Hole tl) a1 with inject_only_node tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_only_packet (Packet (Single_child hd bd) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_only_packet (Packet (Pair_yellow hd bd cr) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_only_packet (Packet (Pair_orange hd cl bd) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Returns an only node containing one element. *)
Equations single_node {A l}
  (a1 : stored A l) :
  { st : node A l 0 only green |
    forall (l : list A), node_seq st l = stored_seq a1 } :=
single_node a1 with buffer.single a1 => { | ? p := ? Only_end p }.

(* Returns a packet containing one element. *)
Equations single_packet {A l}
  (a1 : stored A l) :
  { pkt : packet A l (S l) 0 only green |
    forall (l : list A), packet_seq pkt l = stored_seq a1 } :=
single_packet a1 with single_node a1 => { | ? tl := ? Packet Hole tl }.

(* Returns a chain containing one element. *)
Equations single_chain {A l}
  (a1 : stored A l) :
  { c : chain A l single only green green |
    chain_seq c = stored_seq a1 } :=
single_chain a1 with single_packet a1 => {
  | ? pkt := ? Single G pkt Empty }.

(* UIP is needed to simplify chains with the same left and right colors. *)
Set Equations With UIP.

(* Pushes on a left chain. *)
Equations push_left_chain {A l C}
  (a1 : stored A l)
  (c : chain A l single left C C) :
  { c' : chain A l single left C C |
    chain_seq c' = stored_seq a1 ++ chain_seq c } :=
push_left_chain a1 (Single reg pkt c)
  with push_left_packet a1 pkt => { | ? pkt' := ? Single reg pkt' c }.

(* Injects on a right chain. *)
Equations inject_right_chain {A l C}
  (c : chain A l single right C C)
  (a1 : stored A l) :
  { c' : chain A l single right C C |
    chain_seq c' = chain_seq c ++ stored_seq a1 } :=
inject_right_chain (Single reg pkt c) a1
  with inject_right_packet pkt a1 => { | ? pkt' := ? Single reg pkt' c }.

(* Pushse on a non-empty only chain. *)
Equations push_ne_chain {A l ar lC rC}
  (a1 : stored A l)
  (c : chain A l (S ar) only lC rC) :
  { c' : chain A l (S ar) only lC rC |
    chain_seq c' = stored_seq a1 ++ chain_seq c } :=
push_ne_chain a1 (Single reg pkt c) with push_only_packet a1 pkt => {
  | ? pkt' := ? Single reg pkt' c };
push_ne_chain a1 (Pair cl cr) with push_left_chain a1 cl => {
  | ? cl' := ? Pair cl' cr }.

(* Injects on a non-empty only chain. *)
Equations inject_ne_chain {A l ar lC rC}
  (c : chain A l (S ar) only lC rC)
  (a1 : stored A l) :
  { c' : chain A l (S ar) only lC rC |
    chain_seq c' = chain_seq c ++ stored_seq a1 } :=
inject_ne_chain (Single reg pkt c) a1 with inject_only_packet pkt a1 => {
  | ? pkt' := ? Single reg pkt' c };
inject_ne_chain (Pair cl cr) a1 with inject_right_chain cr a1 => {
  | ? cr' := ? Pair cl cr' }.

(* Pushes on a semi-regular cadeque. *)
Equations semi_push {A l}
  (a1 : stored A l)
  (sd : semi_cadeque A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' = stored_seq a1 ++ semi_cadeque_seq sd } :=
semi_push a1 (Semi Empty) with single_chain a1 => {
  | ? c := ? Semi c };
semi_push a1 (Semi c) with push_ne_chain a1 c => {
  | ? c' := ? Semi c' }.

(* Injects on a semi-regular cadeque. *)
Equations semi_inject {A l}
  (sd : semi_cadeque A l)
  (a1 : stored A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' = semi_cadeque_seq sd ++ stored_seq a1 } :=
semi_inject (Semi Empty) a1 with single_chain a1 => {
  | ? c := ? Semi c };
semi_inject (Semi c) a1 with inject_ne_chain c a1 => {
  | ? c' := ? Semi c' }.

(* Pushes a vector on a semi-regular cadeque. *)
Equations push_vector {A l n}
  (v : vector (stored A l) n)
  (sd : semi_cadeque A l) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' =
      concat (map stored_seq (vector_seq v)) ++ semi_cadeque_seq sd } :=
push_vector V0 sd0 := ? sd0;
push_vector (V1 a1) sd0 with semi_push a1 sd0 => { | ? sd1 := ? sd1 };
push_vector (V2 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 := ? sd2 } };
push_vector (V3 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 := ? sd3 } } };
push_vector (V4 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 := ? sd4 } } } };
push_vector (V5 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 := ? sd5 } } } } };
push_vector (V6 a6 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 with semi_push a6 sd5 => { | ? sd6 := ? sd6 } } } } } }.

(* Injects a vector on a semi-regular cadeque. *)
Equations inject_vector {A l n}
  (sd : semi_cadeque A l)
  (v : vector (stored A l) n) :
  { sd' : semi_cadeque A l |
    semi_cadeque_seq sd' =
      semi_cadeque_seq sd ++ concat (map stored_seq (vector_seq v)) } :=
inject_vector sd0 V0 := ? sd0;
inject_vector sd0 (V1 a1) with semi_inject sd0 a1 => { | ? sd1 := ? sd1 };
inject_vector sd0 (V2 a1 a2) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 := ? sd2 } };
inject_vector sd0 (V3 a1 a2 a3) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 := ? sd3 } } };
inject_vector sd0 (V4 a1 a2 a3 a4) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 := ? sd4 } } } };
inject_vector sd0 (V5 a1 a2 a3 a4 a5) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 := ? sd5 } } } } };
inject_vector sd0 (V6 a1 a2 a3 a4 a5 a6) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 with semi_inject sd5 a6 => { | ? sd6 := ? sd6 } } } } } }.

(* Returns the triple coloring rule associated to a yellow or orange node with
   one child. *)
Equations to_triple_coloring {A l k y o C} :
  node A l single k (Mix NoGreen y o NoRed) ->
  triple_coloring (Mix NoGreen y o NoRed) single C C C :=
to_triple_coloring (Only  YN _ _) := YT;
to_triple_coloring (Left  YN _ _) := YT;
to_triple_coloring (Right YN _ _) := YT;
to_triple_coloring (Only  ON _ _) := OST;
to_triple_coloring (Left  ON _ _) := OST;
to_triple_coloring (Right ON _ _) := OST.

(* Returns the triple representation of a non-empty only chain. *)
Equations triple_of_chain {A l k C}  (c : chain A l single k C C) :
  { t : triple A l k C | chain_seq c = triple_seq t } :=
triple_of_chain (Single G (Packet Hole tl) child) :=
  ? Triple GT tl child;
triple_of_chain (Single reg (Packet (Single_child hd bd) tl) rest) :=
  ? Triple (to_triple_coloring hd) hd (Single reg (Packet bd tl) rest);
triple_of_chain (Single reg (Packet (Pair_yellow hd bd cr) tl) rest) :=
  ? Triple YT hd (Pair (Single reg (Packet bd tl) rest) cr);
triple_of_chain (Single reg (Packet (Pair_orange hd cl bd) tl) rest) :=
  ? Triple OPT hd (Pair cl (Single reg (Packet bd tl) rest));
triple_of_chain (Single R (Packet Hole (Only RN p s)) child) :=
  ? Triple RT (Only RN p s) child;
triple_of_chain (Single R (Packet Hole (Left RN p s)) child) :=
  ? Triple RT (Left RN p s) child;
triple_of_chain (Single R (Packet Hole (Right RN p s)) child) :=
  ? Triple RT (Right RN p s) child.

(* Returns the non-empty only chain associated to a triple. *)
Equations chain_of_triple {A l k C} (t : triple A l k C) :
  { c : chain A l single k C C | chain_seq c = triple_seq t } :=
chain_of_triple (Triple GT hd child) :=
  ? Single G (Packet Hole hd) child;
chain_of_triple (Triple YT hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple YT hd (Pair (Single reg (Packet bd tl) rest) cr)) :=
  ? Single reg (Packet (Pair_yellow hd bd cr) tl) rest;
chain_of_triple (Triple OST hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple OPT hd (Pair cl (Single reg (Packet bd tl) rest))) :=
  ? Single reg (Packet (Pair_orange hd cl bd) tl) rest;
chain_of_triple (Triple RT hd child) :=
  ? Single R (Packet Hole hd) child.

(* Makes a left [left_right_triple] out of an only triple. *)
Equations left_of_only {A l C} (t : triple A l only C) :
  { lt : left_right_triple A l left C | lr_triple_seq lt = triple_seq t } :=
left_of_only (Triple GT (Only_end p) Empty) with buffer.has7s p => {
  | ? inl v := ? Not_enough v;
  | ? inr (p1, z2, z1) :=
    ? Ok_lrt (Triple GT (Left EN p1 (z2, z1)) Empty) };
left_of_only (Triple tc (Only nc p s) child) with buffer.eject2 s => {
  | ? (s1, z2, z1) with inject_ne_chain child (Small s1) => {
    | ? child1 := ? Ok_lrt (Triple tc (Left nc p (z2, z1)) child1) } }.

(* Makes a right [left_right_triple] out of an only triple. *)
Equations right_of_only {A l C} (t : triple A l only C) :
  { rt : left_right_triple A l right C | lr_triple_seq rt = triple_seq t } :=
right_of_only (Triple GT (Only_end s) Empty) with buffer.has7p s => {
  | ? inl v := ? Not_enough v;
  | ? inr (a1, a2, s1) :=
    ? Ok_lrt (Triple GT (Right EN (a1, a2) s1) Empty) };
right_of_only (Triple tc (Only nc p s) child) with buffer.pop2 p => {
  | ? (a1, a2, p1) with push_ne_chain (Small p1) child => {
    | ? child1 := ? Ok_lrt (Triple tc (Right nc (a1, a2) s) child1) } }.

(* Takes a suffix of at least one element and a right triple and returns a
   stored triple and a left suffix. *)
Equations stored_of_right {A l ql C}
  (sl : suffix A l (1 + ql))
  (tr : triple A l right C) :
  { '(stored, (z2, z1)) :
    stored A (S l) * (stored A l * stored A l) |
    stored_seq stored ++ stored_seq z2 ++ stored_seq z1 =
    suffix_seq sl ++ triple_seq tr } :=
stored_of_right sl (Triple tc (Right nc (st1, st2) sr) child)
  with buffer.inject2 sl st1 st2 => {
    | ? p1 with buffer.eject2 sr => {
      | ? (s1, z2, z1) := ? (Big p1 child s1, (z2, z1)) } }.

(* Takes a left triple and a prefix of at least one element and returns a
   right prefix and a stored triple. *)
Equations stored_of_left {A l qr C}
  (tl : triple A l left C)
  (pr : prefix A l (1 + qr)) :
  { '((a1, a2), stored) :
    (stored A l * stored A l) * stored A (S l) |
    stored_seq a1 ++ stored_seq a2 ++ stored_seq stored =
    triple_seq tl ++ prefix_seq pr } :=
stored_of_left (Triple tc (Left nc pl (z2, z1)) child) pr
  with buffer.push2 z2 z1 pr => {
    | ? s1 with buffer.pop2 pl => {
      | ? (st1, st2, p1) := ? ((st1, st2), Big p1 child s1) } }.

(* Makes a left triple out of a pair of left and right triples. *)
Equations left_of_pair {A l lC rC}
  (tl : triple A l left lC) (tr : triple A l right rC) :
  { tl' : triple A l left lC |
    triple_seq tl' = triple_seq tl ++ triple_seq tr } :=
left_of_pair (Triple GT (Left EN p (z2, z1)) Empty) tr
  with buffer.inject p z2, buffer.single z1 => {
    | ? p1, ? s1 with stored_of_right s1 tr => {
      | ? (stored, s2) with single_chain stored => {
        | ? child := ? Triple OST (Left ON p1 s2) child } } };
left_of_pair (Triple tc (Left nc p (z2, z1)) child) tr
  with buffer.pair z2 z1 => { | ? s with stored_of_right s tr => {
    | ? (stored, s1) with inject_ne_chain child stored => {
      | ? child1 := ? Triple tc (Left nc p s1) child1 } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Makes a right triple out of a pair of left and right triples. *)
Equations right_of_pair {A l lC rC}
  (tl : triple A l left lC) (tr : triple A l right rC) :
  { tr' : triple A l right rC |
    triple_seq tr' = triple_seq tl ++ triple_seq tr } :=
right_of_pair tl (Triple GT (Right EN (a1, a2) s) Empty)
  with buffer.single a1, buffer.push a2 s => {
    | ? p1, ? s1 with stored_of_left tl p1 => {
      | ? (p2, stored) with single_chain stored => {
        | ? child := ? Triple OST (Right ON p2 s1) child } } };
right_of_pair tl (Triple tc (Right nc (a1, a2) s) child)
  with buffer.pair a1 a2 => { | ? p with stored_of_left tl p => {
    | ? (p1, stored) with push_ne_chain stored child => {
      | ? child1 := ? Triple tc (Right nc p1 s) child1 } } }.

(* Makes a left [left_right_triple] out of a chain. *)
Equations make_left {A l ar lC rC} (c : chain A l ar only lC rC) :
  { t : left_right_triple A l left lC | lr_triple_seq t = chain_seq c } :=
make_left Empty := ? Not_enough V0;
make_left (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with left_of_only t => { | ? t' := ? t' } };
make_left (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with left_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Makes a right [left_right_triple] out of a chain. *)
Equations make_right {A l ar lC rC} (c : chain A l ar only lC rC) :
  { t : left_right_triple A l right rC | lr_triple_seq t = chain_seq c } :=
make_right Empty := ? Not_enough V0;
make_right (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with right_of_only t => { | ? t' := ? t' } };
make_right (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with right_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Concatenates two semi-regular cadeques. *)
Equations semi_concat {A l} (s1 s2 : semi_cadeque A l) :
  { s3 : semi_cadeque A l |
    semi_cadeque_seq s3 = semi_cadeque_seq s1 ++ semi_cadeque_seq s2 } :=
semi_concat (Semi c1) (Semi c2) with make_left c1 => {
  | ? Not_enough v with push_vector v (Semi c2) => {
    | ? c3 := ? c3 };
  | ? Ok_lrt tl with make_right c2 => {
    | ? Not_enough v with inject_vector (Semi c1) v => {
      | ? c3 := ? c3 };
    | ? Ok_lrt tr with chain_of_triple tl, chain_of_triple tr => {
      | ? cl, ? cr := ? Semi (Pair cl cr) } } }.

(* Returns the orange triple coloring corresponding to the child chain. *)
Equations orange_tc {A l ar rC} :
  chain A l (S ar) only green rC ->
  triple_coloring orange (S ar) green rC rC :=
orange_tc (Single _ _ _) := OST;
orange_tc (Pair _ _)     := OPT.

(* Pops from a green left triple. *)
Equations pop_left_green {A l} (tl : triple A l left green) :
  { '(a1, pt) : stored A l * partial_triple A l pair left |
    triple_seq tl = stored_seq a1 ++ pt_triple_seq pt } :=
pop_left_green (Triple GT (Left EN p (z2, z1)) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has5 p1 => {
    | ? inl (a2, a3, a4, a5) := ? (a1, Six_elements (a2, a3, a4, a5, z2, z1));
    | ? inr p2 => ? (a1, Ok_pt (Triple GT (Left EN p2 (z2, z1)) Empty)) } };
pop_left_green (Triple GT (Left GN p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple YT (Left YN p1 s) child)) };
pop_left_green (Triple YT (Left YN p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple (orange_tc child) (Left ON p1 s) child)) };
pop_left_green (Triple OST (Left ON p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple RT (Left RN p1 s) child)) };
pop_left_green (Triple OPT (Left ON p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple RT (Left RN p1 s) child)) }.

(* Ejects from a green right triple. *)
Equations eject_right_green {A l} (tr : triple A l right green) :
  { '(pt, z1) : partial_triple A l pair right * stored A l |
    triple_seq tr = pt_triple_seq pt ++ stored_seq z1 } :=
eject_right_green (Triple GT (Right EN (a1, a2) s) Empty)
  with buffer.eject s => { | ? (s1, z1) with buffer.has5 s1 => {
    | ? inl (z5, z4, z3, z2) := ? (Six_elements (a1, a2, z5, z4, z3, z2), z1);
    | ? inr s2 => ? (Ok_pt (Triple GT (Right EN (a1, a2) s2) Empty), z1) } };
eject_right_green (Triple GT (Right GN p s) child) with buffer.eject s => {
  | ? (s1, z1) := ? (Ok_pt (Triple YT (Right YN p s1) child), z1) };
eject_right_green (Triple YT (Right YN p s) child)
  with buffer.eject s => { | ? (s1, z1) :=
    ? (Ok_pt (Triple (orange_tc child) (Right ON p s1) child), z1) };
eject_right_green (Triple OST (Right ON p s) child)
  with buffer.eject s => { | ? (s1, z1) :=
    ? (Ok_pt (Triple RT (Right RN p s1) child), z1) };
eject_right_green (Triple OPT (Right ON p s) child)
  with buffer.eject s => { | ? (s1, z1) :=
    ? (Ok_pt (Triple RT (Right RN p s1) child), z1) }.

(* Pops from a green only triple. *)
Equations pop_only_green {A l} (t : triple A l only green) :
  { '(st1, pt) : stored A l * partial_triple A l single only |
    triple_seq t = stored_seq st1 ++ pt_triple_seq pt } :=
pop_only_green (Triple GT (Only_end p) Empty) with buffer.pop p => {
  | ? (st1, p1) with buffer.has1 p1 => {
    | ? None := ? (st1, Zero_element);
    | ? Some p2 := ? (st1, Ok_pt (Triple GT (Only_end p2) Empty)) } };
pop_only_green (Triple GT (Only GN p s) child) with buffer.pop p => {
  | ? (st1, p1) := ? (st1, Ok_pt (Triple YT (Only YN p1 s) child)) };
pop_only_green (Triple YT (Only YN p s) child) with buffer.pop p => {
  | ? (st1, p1) :=
    ? (st1, Ok_pt (Triple (orange_tc child) (Only ON p1 s) child)) };
pop_only_green (Triple OST (Only ON p s) child) with buffer.pop p => {
  | ? (st1, p1) := ? (st1, Ok_pt (Triple RT (Only RN p1 s) child)) };
pop_only_green (Triple OPT (Only ON p s) child) with buffer.pop p => {
  | ? (st1, p1) := ? (st1, Ok_pt (Triple RT (Only RN p1 s) child)) }.

(* Ejects from a green only triple. *)
Equations eject_only_green {A l} (t : triple A l only green) :
  { '(pt, z1) : partial_triple A l single only * stored A l |
    triple_seq t = pt_triple_seq pt ++ stored_seq z1 } :=
eject_only_green (Triple GT (Only_end s) Empty) with buffer.eject s => {
  | ? (st1, z1) with buffer.has1 st1 => {
    | ? None := ? (Zero_element, z1);
    | ? Some s2 := ? (Ok_pt (Triple GT (Only_end s2) Empty), z1) } };
eject_only_green (Triple GT (Only GN p s) child) with buffer.eject s => {
  | ? (st1, z1) := ? (Ok_pt (Triple YT (Only YN p st1) child), z1) };
eject_only_green (Triple YT (Only YN p s) child) with buffer.eject s => {
  | ? (st1, z1) :=
    ? (Ok_pt (Triple (orange_tc child) (Only ON p st1) child), z1) };
eject_only_green (Triple OST (Only ON p s) child) with buffer.eject s => {
  | ? (st1, z1) := ? (Ok_pt (Triple RT (Only RN p st1) child), z1) };
eject_only_green (Triple OPT (Only ON p s) child) with buffer.eject s => {
  | ? (st1, z1) := ? (Ok_pt (Triple RT (Only RN p st1) child), z1) }.

(* Takes an green only triple and represent it as a sandwich. *)
Equations sandwich_only_green {A l} (t : triple A l only green) :
  { s : sandwich (stored A l) (partial_triple A l single only) |
    triple_seq t = sandwich_seq stored_seq pt_triple_seq s } :=
sandwich_only_green (Triple GT (Only_end p) Empty) with buffer.pop p => {
  | ? (st1, p1) with buffer.has1 p1 => {
    | ? None := ? Alone st1;
    | ? Some s with buffer.eject s => {
      | ? (s1, z1) with buffer.has1 s1 => {
        | ? None := ? Sandwich st1 Zero_element z1;
        | ? Some b :=
          ? Sandwich st1 (Ok_pt (Triple GT (Only_end b) Empty)) z1 } } } };
sandwich_only_green (Triple GT (Only GN p s) child)
  with buffer.pop p, buffer.eject s => { | ? (st1, p1), ? (s1, z1) :=
    ? Sandwich st1 (Ok_pt (Triple YT (Only YN p1 s1) child)) z1 };
sandwich_only_green (Triple YT (Only YN p s) child)
  with buffer.pop p, buffer.eject s => { | ? (st1, p1), ? (s1, z1) :=
    ? Sandwich st1 (Ok_pt (Triple (orange_tc child) (Only ON p1 s1) child)) z1 };
sandwich_only_green (Triple OST (Only ON p s) child)
  with buffer.pop p, buffer.eject s => { | ? (st1, p1), ? (s1, z1) :=
    ? Sandwich st1 (Ok_pt (Triple RT (Only RN p1 s1) child)) z1 };
sandwich_only_green (Triple OPT (Only ON p s) child)
  with buffer.pop p, buffer.eject s => { | ? (st1, p1), ? (s1, z1) :=
    ? Sandwich st1 (Ok_pt (Triple RT (Only RN p1 s1) child)) z1 }.

(* Adapts a node coloring to a prefix of 8 or more elements. *)
Equations adapt_to_prefix {qp qs q ar C} :
  node_coloring qp qs ar C -> node_coloring (3 + q) qs ar C :=
adapt_to_prefix GN := GN;
adapt_to_prefix YN := YN;
adapt_to_prefix ON := ON;
adapt_to_prefix RN := RN;
adapt_to_prefix EN := EN.

(* Makes an only triple out of six elements and a right triple. *)
Equations only_of_right {A l C}
  (six : six_stored A l)
  (tr : triple A l right C) :
  { t : triple A l only C |
    triple_seq t = six_stored_seq six ++ triple_seq tr } :=
only_of_right (a1, a2, a3, a4, a5, a6) (Triple GT (Right EN (a7, a8) s) Empty)
    with buffer.push2 a7 a8 s => {
      | ? s1 with buffer.push6 a1 a2 a3 a4 a5 a6 s1 => {
        | ? s2 := ? Triple GT (Only_end s2) Empty } };
only_of_right (a1, a2, a3, a4, a5, a6) (Triple tc (Right nc (a7, a8) s) child)
  with buffer.pair a7 a8 => {
    | ? p1 with buffer.push6 a1 a2 a3 a4 a5 a6 p1 => {
      | ? p2 := ? Triple tc (Only (adapt_to_prefix nc) p2 s) child } }.

(* Adapts a node coloring to a suffix of 8 or more elements. *)
Equations adapt_to_suffix {qp qs q ar C} :
  node_coloring qp qs ar C -> node_coloring qp (3 + q) ar C :=
adapt_to_suffix GN := GN;
adapt_to_suffix YN := YN;
adapt_to_suffix ON := ON;
adapt_to_suffix RN := RN;
adapt_to_suffix EN := EN.

(* Makes an only triple out of a left triple and six elements. *)
Equations only_of_left {A l C}
  (tl : triple A l left C)
  (six : six_stored A l) :
  { t : triple A l only C |
    triple_seq t = triple_seq tl ++ six_stored_seq six } :=
only_of_left (Triple GT (Left EN p (z8, z7)) Empty) (z6, z5, z4, z3, z2, z1)
    with buffer.inject2 p z8 z7 => {
      | ? p1 with buffer.inject6 p1 z6 z5 z4 z3 z2 z1 => {
        | ? p2 := ? Triple GT (Only_end p2) Empty } };
only_of_left (Triple tc (Left nc p (z8, z7)) child) (z6, z5, z4, z3, z2, z1)
  with buffer.pair z8 z7 => {
    | ? s1 with buffer.inject6 s1 z6 z5 z4 z3 z2 z1 => {
      | ? s2 := ? Triple tc (Only (adapt_to_suffix nc) p s2) child } }.

(* Pops from a green pair chain. *)
Equations pop_pair_green {A l}
  (c : chain A l pair only green green) :
  { '(a1, sd) : stored A l * semi_cadeque A l |
    chain_seq c = stored_seq a1 ++ semi_cadeque_seq sd } :=
pop_pair_green (Pair cl cr) with triple_of_chain cl => {
  | ? tl with pop_left_green tl => {
    | ? (a1, Six_elements six) with triple_of_chain cr => {
      | ? tr with only_of_right six tr => {
        | ? t with chain_of_triple t => {
          | ? c := ? (a1, Semi c) } } };
    | ? (a1, Ok_pt tl1) with chain_of_triple tl1 => {
      | ? cl1 := ? (a1, Semi (Pair cl1 cr)) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Ejects from a green pair chain. *)
Equations eject_pair_green {A l}
  (c : chain A l pair only green green) :
  { '(sd, a1) : semi_cadeque A l * stored A l |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq a1 } :=
eject_pair_green (Pair cl cr) with triple_of_chain cr => {
  | ? tr with eject_right_green tr => {
    | ? (Six_elements six, a1) with triple_of_chain cl => {
      | ? tl with only_of_left tl six => {
        | ? t with chain_of_triple t => {
          | ? c := ? (Semi c, a1) } } };
    | ? (Ok_pt tr1, a1) with chain_of_triple tr1 => {
      | ? cr1 := ? (Semi (Pair cl cr1), a1) } } }.

(* Takes a green pair chain and represent it as a sandwich. *)
Equations sandwich_pair_green {A l}
  (c : chain A l pair only green green) :
  { s : sandwich (stored A l) (semi_cadeque A l) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_pair_green (Pair cl cr)
  with triple_of_chain cl, triple_of_chain cr => {
    | ? tl, ? tr with pop_left_green tl, eject_right_green tr => {
      | ? (a1, Six_elements (a2, a3, a4, a5, a6, a7)),
        ? (Six_elements (z7, z6, z5, z4, z3, z2), z1) with buffer.empty => {
        | ? b with buffer.push6 a2 a3 a4 a5 a6 a7 b => {
          | ? b1 with buffer.inject6 b1 z7 z6 z5 z4 z3 z2 => { | ? b2 :=
            ? Sandwich
              a1
              (Semi (Single G (Packet Hole (Only_end b2)) Empty))
              z1 } } };
      | ? (a1, Six_elements six), ? (Ok_pt tr1, z1)
        with only_of_right six tr1 => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Six_elements six, z1)
        with only_of_left tl1 six => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Ok_pt tr1, z1)
        with chain_of_triple tl1, chain_of_triple tr1 => {
          | ? cl1, ? cr1 :=
            ? Sandwich a1 (Semi (Pair cl1 cr1)) z1 } } }.

(* Pops from a non-empty green chain. *)
Equations pop_green {A l ar} (c : chain A l (S ar) only green green) :
  { '(a1, sd) : stored A l * semi_cadeque A l |
    chain_seq c = stored_seq a1 ++ semi_cadeque_seq sd } :=
pop_green (ar := 0) c with triple_of_chain c => {
  | ? t with pop_only_green t => {
    | ? (a1, Zero_element) := ? (a1, Semi Empty)
    | ? (a1, Ok_pt t1) with chain_of_triple t1 => {
      | ? c1 := ? (a1, Semi c1) } } };
pop_green (ar := 1) c with pop_pair_green c => {
  | ? (a1, sd) := ? (a1, sd) }.

(* Ejects from a non-empty green chain. *)
Equations eject_green {A l ar} (c : chain A l (S ar) only green green) :
  { '(sd, a1) : semi_cadeque A l * stored A l |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq a1 } :=
eject_green (ar := 0) c with triple_of_chain c => {
  | ? t with eject_only_green t => {
    | ? (Zero_element, a1) := ? (Semi Empty, a1);
    | ? (Ok_pt t1, a1) with chain_of_triple t1 => {
      | ? c1 := ? (Semi c1, a1) } } };
eject_green (ar := 1) c with eject_pair_green c => {
  | ? (sd, a1) := ? (sd, a1) }.

(* Takes a non-empty green chain and represent it as a sandwich. *)
Equations sandwich_green {A l ar}
  (c : chain A l (S ar) only green green) :
  { s : sandwich (stored A l) (semi_cadeque A l) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_green (ar := 0) c with triple_of_chain c => {
  | ? t with sandwich_only_green t => {
    | ? Alone a1 := ? Alone a1;
    | ? Sandwich a1 Zero_element z1 := ? Sandwich a1 (Semi Empty) z1;
    | ? Sandwich a1 (Ok_pt t1) z1 with chain_of_triple t1 => {
      | ? c1 := ? Sandwich a1 (Semi c1) z1 } } };
sandwich_green (ar := 1) c with sandwich_pair_green c => { | ? res := ? res }.

(* Takes a prefix of at least 5 elements, a prefix of at least 3 elements and
   and a semi-regular cadeque of stored triples. Rearranges the elements of the
   second prefix to make the first one green (i.e. at least 8 elements). *)
Equations make_green_prefix {A l q qstored}
  (p : prefix A l (5 + q))
  (pstored : prefix A l (3 + qstored))
  (child : semi_cadeque A (S l)) :
  { '(pgreen, child') : green_buffer A l * semi_cadeque A (S l) |
    green_buffer_seq pgreen ++ semi_cadeque_seq child' =
    prefix_seq p ++ prefix_seq pstored ++ semi_cadeque_seq child } :=
make_green_prefix p pstored child with buffer.has3p pstored => {
  | ? ((a1, a2, a3), inl v) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with buffer.inject_vector pgreen v => {
      | ? pgreen1 := ? (Gbuf pgreen1, child) } };
  | ? ((a1, a2, a3), inr pstored1) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with semi_push (Small pstored1) child => {
      | ? child1 := ? (Gbuf pgreen, child1) } } }.

(* Takes a semi-regular cadeque of stored triples, a suffix of at least 3
   elements and a suffix of at least 5 elements. Rearranges the elements of
   the first suffix to make the second one green (i.e. at least 8 elements). *)
Equations make_green_suffix {A l q qstored}
  (child : semi_cadeque A (S l))
  (sstored : suffix A l (3 + qstored))
  (s : suffix A l (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S l) * green_buffer A l |
    semi_cadeque_seq child' ++ green_buffer_seq sgreen =
    semi_cadeque_seq child ++ suffix_seq sstored ++ suffix_seq s } :=
make_green_suffix child sstored s with buffer.has3s sstored => {
  | ? (inl v, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with buffer.push_vector v sgreen => {
      | ? sgreen1 := ? (child, Gbuf sgreen1) } };
  | ? (inr sstored1, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with semi_inject child (Small sstored1) => {
      | ? child1 := ? (child1, Gbuf sgreen) } } }.

(* Takes a stored triple and a semi-regular cadeque of stored triples. Extracts
   the prefix of the stored triple, the remaining elements and the semi
   regular cadeque form a new semi-regular cadeque. *)
Equations extract_prefix {A l}
  (stored : stored A (S l))
  (child : semi_cadeque A (S l)) :
  { '(pstored, child') : stored_buffer A l * semi_cadeque A (S l) |
    stored_buffer_seq pstored ++ semi_cadeque_seq child' =
    stored_seq stored ++ semi_cadeque_seq child } :=
extract_prefix (Small p) child := ? (Sbuf p, child);
extract_prefix (Big p schild s) child with semi_push (Small s) child => {
    | ? child1 with semi_concat (Semi schild) child1 => {
      | ? child2 := ? (Sbuf p, child2) } }.

(* Takes a semi-regular cadeque of stored triples and a stored triple. Extracs
   the suffix of the stored triple, the semi-regular cadeque and the remaining
   elements form a new semi-regular cadeque. *)
Equations extract_suffix {A l}
  (child : semi_cadeque A (S l))
  (stored : stored A (S l)) :
  { '(child', sstored) : semi_cadeque A (S l) * stored_buffer A l |
    semi_cadeque_seq child' ++ stored_buffer_seq sstored =
    semi_cadeque_seq child ++ stored_seq stored } :=
extract_suffix child (Small s) := ? (child, Sbuf s);
extract_suffix child (Big p schild s) with semi_inject child (Small p) => {
  | ? child1 with semi_concat child1 (Semi schild) => {
    | ? child2 := ? (child2, Sbuf s) } }.

(* Takes a prefix of at least 5 elements and a semi-regular cadeque of stored
   triples. Rearranges elements of the semi-regular cadeque to make the prefix
   green. *)
Equations ensure_green_prefix {A l q ar}
  (p : prefix A l (5 + q))
  (child : chain A (S l) (S ar) only green green) :
  { '(pgreen, child') : green_buffer A l * semi_cadeque A (S l) |
    prefix_seq p ++ chain_seq child =
    green_buffer_seq pgreen ++ semi_cadeque_seq child' } :=
ensure_green_prefix p child with pop_green child => {
  | ? (stored, child1) with extract_prefix stored child1 => {
    | ? (Sbuf pstored, child2) with make_green_prefix p pstored child2 => {
      | ? (pg, child3) := ? (pg, child3) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Takes a semi-regular cadeque of stored triples and a suffix of at least 5
   elements. Rearranges elements of the semi-regular cadeque to make the suffix
   green. *)
Equations ensure_green_suffix {A l q ar}
  (child : chain A (S l) (S ar) only green green)
  (s : suffix A l (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S l) * green_buffer A l |
    chain_seq child ++ suffix_seq s =
    semi_cadeque_seq child' ++ green_buffer_seq sgreen } :=
ensure_green_suffix child s with eject_green child => {
  | ? (child1, stored) with extract_suffix child1 stored => {
    | ? (child2, Sbuf sstored) with make_green_suffix child2 sstored s => {
      | ? (child3, sg) := ? (child3, sg) } } }.

(* Takes a body, a following red left node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_left {A hl tl hk ar}
  (bd : body A hl tl hk left)
  (red : node A tl (S ar) left red)
  (child : chain A (S tl) (S ar) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_left bd (Left RN p s) child
  with ensure_green_prefix p child => {
    | ? (Gbuf p1, Semi Empty) :=
      ? Single G (Packet bd (Left EN p1 s)) Empty;
    | ? (Gbuf p1, Semi child1) :=
      ? Single G (Packet bd (Left GN p1 s)) child1 }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases.

   The [unfold Nat.add] tactic ensures that natural numbers that are equal
   are indeed type checked as equal, some additions interfer with the equality
   otherwise. *)
#[local] Obligation Tactic := try (cbn; unfold Nat.add; hauto db:rlist, rassoc).

(* Takes a body, a following red right node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_right {A hl tl hk ar}
  (bd : body A hl tl hk right)
  (red : node A tl (S ar) right red)
  (child : chain A (S tl) (S ar) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_right bd (Right RN p s) child
  with ensure_green_suffix child s => {
    | ? (Semi Empty, Gbuf s1) :=
      ? Single G (Packet bd (Right EN p s1)) Empty;
    | ? (Semi child1, Gbuf s1) :=
      ? Single G (Packet bd (Right GN p s1)) child1 }.

(* Takes a body and a following green triple, and makes a green chain out of
   them. *)
Equations make_green_only {A hl tl hk qp qs}
  (bd : body A hl tl hk only)
  (p : prefix A tl (8 + qp))
  (child : semi_cadeque A (S tl))
  (s : prefix A tl (8 + qs)) :
  { c : chain A hl single hk green green |
    chain_seq c =
      body_seq bd (prefix_seq p ++ semi_cadeque_seq child ++ suffix_seq s) } :=
make_green_only bd p (Semi Empty) s with buffer.has3p8 s => {
  | ? inl ((a1, a2, a3, a4, a5, a6, a7, a8), v)
    with buffer.inject8 p a1 a2 a3 a4 a5 a6 a7 a8 => {
      | ? p1 with buffer.inject_vector p1 v => {
        | ? p2 :=
          ? Single G (Packet bd (Only_end p2)) Empty } };
  | ? inr (small, s1) with single_chain (Small small) => {
    | ? child :=
      ? Single G (Packet bd (Only GN p s1)) child } };
make_green_only bd p (Semi child) s :=
  ? Single G (Packet bd (Only GN p s)) child.
Next Obligation. Qed.

(* Changing the default tactics for obligations to be [idtac].

   [hauto] is not used there because it takes too much time to compute, especially in cases where it cannot prove the result. *)
#[local] Obligation Tactic := idtac.

(* Takes a body, a following red only node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_only {A hl tl hk ar}
  (bd : body A hl tl hk only)
  (red : node A tl (S ar) only red)
  (child : chain A (S tl) (S ar) only green green) :
  { c : chain A hl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_only bd (Only RN p s) child
  with buffer.has8 p, buffer.has8 s => {
    | ? inl (a1, a2, a3, a4, a5, vp),
      ? inl (z5, z4, z3, z2, z1, vs) with sandwich_green child => {
      | ? Alone (Small b)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp b => {
          | ? b1 with buffer.inject_5vector b1 z5 z4 z3 z2 z1 vs => {
            | ? b2 := ? Single G (Packet bd (Only_end b2)) Empty } };
      | ? Alone (Big pre1 child1 suf1)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp pre1 => {
          | ? pre2 with buffer.inject_5vector suf1 z5 z4 z3 z2 z1 vs => {
            | ? suf2 with make_green_only bd pre2 (Semi child1) suf2 => {
              | ? res := ? res } } };
      | ? Sandwich storedl child1 storedr
        with extract_prefix storedl child1 => { | ? (Sbuf pre1, child2)
          with extract_suffix child2 storedr => { | ? (child3, Sbuf suf1)
            with buffer.push_5vector a1 a2 a3 a4 a5 vp pre1 => { | ? pre2
              with buffer.inject_5vector suf1 z5 z4 z3 z2 z1 vs => { | ? suf2
                with make_green_only bd pre2 child3 suf2 => {
                  | ? res := ? res } } } } } };
    | ? inl _, ? inr suf1 with ensure_green_prefix p child => {
      | ? (Gbuf pre1, child1) with make_green_only bd pre1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inl _ with ensure_green_suffix child s => {
      | ? (child1, Gbuf suf1) with make_green_only bd pre1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inr suf1 :=
      ? Single G (Packet bd (Only GN pre1 suf1)) child }.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hp2 * Hp1 * Hres Hs2 Hs1 Hchild.
  do 2 rewrite buffer.correct_cmseq in *.
  rewrite Hp, Hs, Hres, Hp2, Hs2, Hchild.
  autorewrite with rlist rassoc.
  do 7 f_equal.
  aac_rewrite Hs1. aac_rewrite Hp1.
  aac_reflexivity.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hres Hchild.
  do 2 rewrite buffer.correct_cmseq in *.
  rewrite Hres, Hs.
  aac_rewrite <-Hchild.
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Takes any chain and makes it green. *)
Equations ensure_green {A l ar k lC rC}
  (c : chain A l ar k lC rC) :
  { c' : chain A l ar k green green | chain_seq c = chain_seq c' } :=
ensure_green Empty := ? Empty;
ensure_green (Single G pkt c) := ? Single G pkt c;
ensure_green (Single R (Packet bd (Only RN p s)) c)
  with green_of_red_only bd (Only RN p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Left RN p s)) c)
  with green_of_red_left bd (Left RN p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Right RN p s)) c)
  with green_of_red_right bd (Right RN p s) c => { | ? c' := ? c' };
ensure_green (Pair cl cr) with ensure_green cl, ensure_green cr => {
  | ? cl', ? cr' := ? Pair cl' cr' }.

(* Regularizes a semi-regular cadeque. *)
Equations regularize {A} (sd : semi_cadeque A 0) :
  { d : cadeque A | cadeque_seq d = semi_cadeque_seq sd } :=
regularize (Semi c) with ensure_green c => { | ? c' := ? T c' }.
