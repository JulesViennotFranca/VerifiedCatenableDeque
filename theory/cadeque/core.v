From Coq Require Import List.
Import ListNotations.
From Equations Require Import Equations.
Require Import Coq.Program.Equality.
From Hammer Require Import Tactics.
From AAC_tactics Require Import AAC.
From AAC_tactics Require Import Instances.
Import Instances.Lists.

From Cadeque.color Require Import GYOR.
From Cadeque.cadeque Require Import buffer types models.

(* The [app] function and the singleton list are made opaque. *)
Opaque app.
Definition singleton {A : Type} (x : A) : list A := [x].
Opaque singleton.

(* Hint databases of rewrites to be used when trying to automatically resolve
   obligations on lists generated by [Equations]. *)
#[export] Hint Rewrite <-app_assoc : rassoc.
#[export] Hint Rewrite app_assoc : lassoc.

#[export] Hint Rewrite app_nil_r : rlist.
#[export] Hint Rewrite app_nil_l : rlist.
#[export] Hint Rewrite map_app : rlist.
#[export] Hint Rewrite concat_app : rlist.

#[export] Hint Rewrite buffer.correct_concat_map_seq : rlist.

(* Notation for dependent types hiding the property on [x]. *)
Notation "? x" := (@exist _ _ x _) (at level 100).

(* Setting the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Pushes on a left node. *)
Equations push_left_node {A lvl nc C}
  (a1 : stored A lvl)
  (st : node A lvl nc left C) :
  { st' : node A lvl nc left C |
    forall (l : list A),
      node_seq st' l = stored_seq a1 ++ node_seq st l } :=
push_left_node a1 (Left Gc p s) with buffer.push a1 p => {
  | ? p' := ? Left Gc p' s };
push_left_node a1 (Left Yc p s) with buffer.push a1 p => {
  | ? p' := ? Left Yc p' s };
push_left_node a1 (Left Oc p s) with buffer.push a1 p => {
  | ? p' := ? Left Oc p' s };
push_left_node a1 (Left Rc p s) with buffer.push a1 p => {
  | ? p' := ? Left Rc p' s };
push_left_node a1 (Left Ec p s) with buffer.push a1 p => {
  | ? p' := ? Left Ec p' s }.

(* Injects on a right node. *)
Equations inject_right_node {A lvl nc C}
  (st : node A lvl nc right C)
  (a1 : stored A lvl) :
  { st' : node A lvl nc right C |
    forall (l : list A),
      node_seq st' l = node_seq st l ++ stored_seq a1 } :=
inject_right_node (Right Gc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right Gc p s' };
inject_right_node (Right Yc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right Yc p s' };
inject_right_node (Right Oc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right Oc p s' };
inject_right_node (Right Rc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right Rc p s' };
inject_right_node (Right Ec p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Right Ec p s' }.

(* Pushes on an only node. *)
Equations push_only_node {A lvl nc C}
  (a1 : stored A lvl)
  (st : node A lvl nc only C) :
  { st' : node A lvl nc only C |
    forall (l : list A),
      node_seq st' l = stored_seq a1 ++ node_seq st l } :=
push_only_node a1 (Only Gc p s) with buffer.push a1 p => {
  | ? p' := ? Only Gc p' s };
push_only_node a1 (Only Yc p s) with buffer.push a1 p => {
  | ? p' := ? Only Yc p' s };
push_only_node a1 (Only Oc p s) with buffer.push a1 p => {
  | ? p' := ? Only Oc p' s };
push_only_node a1 (Only Rc p s) with buffer.push a1 p => {
  | ? p' := ? Only Rc p' s };
push_only_node a1 (Only_end p) with buffer.push a1 p => {
  | ? p' := ? Only_end p' }.

(* Injects on an only node. *)
Equations inject_only_node {A lvl nc C}
  (st : node A lvl nc only C)
  (a1 : stored A lvl) :
  { st' : node A lvl nc only C |
    forall (l : list A),
      node_seq st' l = node_seq st l ++ stored_seq a1 } :=
inject_only_node (Only Gc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only Gc p s' };
inject_only_node (Only Yc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only Yc p s' };
inject_only_node (Only Oc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only Oc p s' };
inject_only_node (Only Rc p s) a1 with buffer.inject s a1 => {
  | ? s' := ? Only Rc p s' };
inject_only_node (Only_end p) a1 with buffer.inject p a1 => {
  | ? p' := ? Only_end p' }.

(* Pushes on a left packet. *)
Equations push_left_packet {A hlvl tlvl nc C}
  (a1 : stored A hlvl)
  (pkt : packet A hlvl tlvl nc left C) :
  { pkt' : packet A hlvl tlvl nc left C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq a1 ++ packet_seq pkt l } :=
push_left_packet a1 (Packet Hole tl) with push_left_node a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_left_packet a1 (Packet (Single_child hd bd) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_left_packet a1 (Packet (Pair_yellow hd bd cr) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_left_packet a1 (Packet (Pair_orange hd cl bd) tl)
  with push_left_node a1 hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on a right packet. *)
Equations inject_right_packet {A hlvl tlvl nc C}
  (pkt : packet A hlvl tlvl nc right C)
  (a1 : stored A hlvl) :
  { pkt' : packet A hlvl tlvl nc right C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq a1 } :=
inject_right_packet (Packet Hole tl) a1 with inject_right_node tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_right_packet (Packet (Single_child hd bd) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_right_packet (Packet (Pair_yellow hd bd cr) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_right_packet (Packet (Pair_orange hd cl bd) tl) a1
  with inject_right_node hd a1 => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Pushes on an only packet. *)
Equations push_only_packet {A hlvl tlvl nc C}
  (a1 : stored A hlvl)
  (pkt : packet A hlvl tlvl nc only C) :
  { pkt' : packet A hlvl tlvl nc only C |
    forall (l : list A),
      packet_seq pkt' l = stored_seq a1 ++ packet_seq pkt l } :=
push_only_packet a1 (Packet Hole tl) with push_only_node a1 tl => {
  | ? tl' := ? Packet Hole tl' };
push_only_packet a1 (Packet (Single_child hd bd) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
push_only_packet a1 (Packet (Pair_yellow hd bd cr) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
push_only_packet a1 (Packet (Pair_orange hd cl bd) tl)
  with push_only_node a1 hd => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Injects on an only packet. *)
Equations inject_only_packet {A hlvl tlvl nc C}
  (pkt : packet A hlvl tlvl nc only C)
  (a1 : stored A hlvl) :
  { pkt' : packet A hlvl tlvl nc only C |
    forall (l : list A),
      packet_seq pkt' l = packet_seq pkt l ++ stored_seq a1 } :=
inject_only_packet (Packet Hole tl) a1 with inject_only_node tl a1 => {
  | ? tl' := ? Packet Hole tl' };
inject_only_packet (Packet (Single_child hd bd) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Single_child hd' bd) tl };
inject_only_packet (Packet (Pair_yellow hd bd cr) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Pair_yellow hd' bd cr) tl };
inject_only_packet (Packet (Pair_orange hd cl bd) tl) a1
  with inject_only_node hd a1 => {
    | ? hd' := ? Packet (Pair_orange hd' cl bd) tl }.

(* Returns an only node containing one element. *)
Equations single_node {A lvl}
  (a1 : stored A lvl) :
  { st : node A lvl 0 only green |
    forall (l : list A), node_seq st l = stored_seq a1 } :=
single_node a1 with buffer.single a1 => { | ? p := ? Only_end p }.

(* Returns a packet containing one element. *)
Equations single_packet {A lvl}
  (a1 : stored A lvl) :
  { pkt : packet A lvl (S lvl) 0 only green |
    forall (l : list A), packet_seq pkt l = stored_seq a1 } :=
single_packet a1 with single_node a1 => { | ? tl := ? Packet Hole tl }.

(* Returns a chain containing one element. *)
Equations single_chain {A lvl}
  (a1 : stored A lvl) :
  { c : chain A lvl single only green green |
    chain_seq c = stored_seq a1 } :=
single_chain a1 with single_packet a1 => {
  | ? pkt := ? Single G pkt Empty }.

(* UIP is needed to simplify chains with the same left and right colors. *)
Set Equations With UIP.

(* Pushes on a left chain. *)
Equations push_left_chain {A lvl C}
  (a1 : stored A lvl)
  (c : chain A lvl single left C C) :
  { c' : chain A lvl single left C C |
    chain_seq c' = stored_seq a1 ++ chain_seq c } :=
push_left_chain a1 (Single reg pkt c)
  with push_left_packet a1 pkt => { | ? pkt' := ? Single reg pkt' c }.

(* Injects on a right chain. *)
Equations inject_right_chain {A lvl C}
  (c : chain A lvl single right C C)
  (a1 : stored A lvl) :
  { c' : chain A lvl single right C C |
    chain_seq c' = chain_seq c ++ stored_seq a1 } :=
inject_right_chain (Single reg pkt c) a1
  with inject_right_packet pkt a1 => { | ? pkt' := ? Single reg pkt' c }.

(* Pushse on a non-empty only chain. *)
Equations push_ne_chain {A lvl ck Cl Cr}
  (a1 : stored A lvl)
  (c : chain A lvl (S ck) only Cl Cr) :
  { c' : chain A lvl (S ck) only Cl Cr |
    chain_seq c' = stored_seq a1 ++ chain_seq c } :=
push_ne_chain a1 (Single reg pkt c) with push_only_packet a1 pkt => {
  | ? pkt' := ? Single reg pkt' c };
push_ne_chain a1 (Pair cl cr) with push_left_chain a1 cl => {
  | ? cl' := ? Pair cl' cr }.

(* Injects on a non-empty only chain. *)
Equations inject_ne_chain {A lvl ck Cl Cr}
  (c : chain A lvl (S ck) only Cl Cr)
  (a1 : stored A lvl) :
  { c' : chain A lvl (S ck) only Cl Cr |
    chain_seq c' = chain_seq c ++ stored_seq a1 } :=
inject_ne_chain (Single reg pkt c) a1 with inject_only_packet pkt a1 => {
  | ? pkt' := ? Single reg pkt' c };
inject_ne_chain (Pair cl cr) a1 with inject_right_chain cr a1 => {
  | ? cr' := ? Pair cl cr' }.

(* Pushes on a semi-regular cadeque. *)
Equations semi_push {A lvl}
  (a1 : stored A lvl)
  (sd : semi_cadeque A lvl) :
  { sd' : semi_cadeque A lvl |
    semi_cadeque_seq sd' = stored_seq a1 ++ semi_cadeque_seq sd } :=
semi_push a1 (Semi Empty) with single_chain a1 => {
  | ? c := ? Semi c };
semi_push a1 (Semi c) with push_ne_chain a1 c => {
  | ? c' := ? Semi c' }.

(* Injects on a semi-regular cadeque. *)
Equations semi_inject {A lvl}
  (sd : semi_cadeque A lvl)
  (a1 : stored A lvl) :
  { sd' : semi_cadeque A lvl |
    semi_cadeque_seq sd' = semi_cadeque_seq sd ++ stored_seq a1 } :=
semi_inject (Semi Empty) a1 with single_chain a1 => {
  | ? c := ? Semi c };
semi_inject (Semi c) a1 with inject_ne_chain c a1 => {
  | ? c' := ? Semi c' }.

(* Pushes a vector on a semi-regular cadeque. *)
Equations push_vector {A lvl n}
  (v : vector (stored A lvl) n)
  (sd : semi_cadeque A lvl) :
  { sd' : semi_cadeque A lvl |
    semi_cadeque_seq sd' =
      concat (map stored_seq (vector_seq v)) ++ semi_cadeque_seq sd } :=
push_vector V0 sd0 := ? sd0;
push_vector (V1 a1) sd0 with semi_push a1 sd0 => { | ? sd1 := ? sd1 };
push_vector (V2 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 := ? sd2 } };
push_vector (V3 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 := ? sd3 } } };
push_vector (V4 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 := ? sd4 } } } };
push_vector (V5 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 := ? sd5 } } } } };
push_vector (V6 a6 a5 a4 a3 a2 a1) sd0 with semi_push a1 sd0 => {
  | ? sd1 with semi_push a2 sd1 => { | ? sd2 with semi_push a3 sd2 => {
  | ? sd3 with semi_push a4 sd3 => { | ? sd4 with semi_push a5 sd4 => {
  | ? sd5 with semi_push a6 sd5 => { | ? sd6 := ? sd6 } } } } } }.

(* Injects a vector on a semi-regular cadeque. *)
Equations inject_vector {A lvl n}
  (sd : semi_cadeque A lvl)
  (v : vector (stored A lvl) n) :
  { sd' : semi_cadeque A lvl |
    semi_cadeque_seq sd' =
      semi_cadeque_seq sd ++ concat (map stored_seq (vector_seq v)) } :=
inject_vector sd0 V0 := ? sd0;
inject_vector sd0 (V1 a1) with semi_inject sd0 a1 => { | ? sd1 := ? sd1 };
inject_vector sd0 (V2 a1 a2) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 := ? sd2 } };
inject_vector sd0 (V3 a1 a2 a3) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 := ? sd3 } } };
inject_vector sd0 (V4 a1 a2 a3 a4) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 := ? sd4 } } } };
inject_vector sd0 (V5 a1 a2 a3 a4 a5) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 := ? sd5 } } } } };
inject_vector sd0 (V6 a1 a2 a3 a4 a5 a6) with semi_inject sd0 a1 => {
  | ? sd1 with semi_inject sd1 a2 => { | ? sd2 with semi_inject sd2 a3 => {
  | ? sd3 with semi_inject sd3 a4 => { | ? sd4 with semi_inject sd4 a5 => {
  | ? sd5 with semi_inject sd5 a6 => { | ? sd6 := ? sd6 } } } } } }.

(* Returns the regularity rule associated to a yellow or orange node with one
    child. *)
Equations to_reg {A lvl nk y o C} :
  node A lvl single nk (Mix NoGreen y o NoRed) ->
  regularity (Mix NoGreen y o NoRed) C single C C :=
to_reg (Only  Yc _ _) := Y;
to_reg (Left  Yc _ _) := Y;
to_reg (Right Yc _ _) := Y;
to_reg (Only  Oc _ _) := OS;
to_reg (Left  Oc _ _) := OS;
to_reg (Right Oc _ _) := OS.

(* Returns the triple representation of a non-empty only chain. *)
Equations triple_of_chain {A lvl nk C}  (c : chain A lvl single nk C C) :
  { t : triple A lvl nk C | chain_seq c = triple_seq t } :=
triple_of_chain (Single G (Packet Hole tl) child) :=
  ? Triple G tl child;
triple_of_chain (Single R (Packet Hole tl) child) :=
  ? Triple R tl child;
triple_of_chain (Single reg (Packet (Single_child hd bd) tl) rest) :=
  ? Triple (to_reg hd) hd (Single reg (Packet bd tl) rest);
triple_of_chain (Single reg (Packet (Pair_yellow hd bd cr) tl) rest) :=
  ? Triple Y hd (Pair (Single reg (Packet bd tl) rest) cr);
triple_of_chain (Single reg (Packet (Pair_orange hd cl bd) tl) rest) :=
  ? Triple OP hd (Pair cl (Single reg (Packet bd tl) rest)).

(* Returns the non-empty only chain associated to a triple. *)
Equations chain_of_triple {A lvl k C} (t : triple A lvl k C) :
  { c : chain A lvl single k C C | chain_seq c = triple_seq t } :=
chain_of_triple (Triple G hd child) :=
  ? Single G (Packet Hole hd) child;
chain_of_triple (Triple Y hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple Y hd (Pair (Single reg (Packet bd tl) rest) cr)) :=
  ? Single reg (Packet (Pair_yellow hd bd cr) tl) rest;
chain_of_triple (Triple OS hd (Single reg (Packet bd tl) rest)) :=
  ? Single reg (Packet (Single_child hd bd) tl) rest;
chain_of_triple (Triple OP hd (Pair cl (Single reg (Packet bd tl) rest))) :=
  ? Single reg (Packet (Pair_orange hd cl bd) tl) rest;
chain_of_triple (Triple R hd child) :=
  ? Single R (Packet Hole hd) child.

(* Makes a left [left_right_triple] out of an only triple. *)
Equations left_of_only {A lvl C} (t : triple A lvl only C) :
  { lt : left_right_triple A lvl left C | lr_triple_seq lt = triple_seq t } :=
left_of_only (Triple G (Only_end p) Empty) with buffer.has7 p => {
  | ? inl v := ? Not_enough v;
  | ? inr p1 with buffer.eject2 p1 => {
    | ? (p2, a2, a1) with buffer.pair a2 a1 => {
      | ? s := ? Ok_lrt (Triple G (Left Ec p2 s) Empty) } } };
left_of_only (Triple reg (Only col p s) child) with buffer.eject2 s => {
  | ? (s1, a2, a1) with buffer.pair a2 a1, inject_ne_chain child (Small s1) => {
    | ? s2, ? child1 :=
      ? Ok_lrt (Triple reg (Left col p s2) child1) } }.

(* Makes a right [left_right_triple] out of an only triple. *)
Equations right_of_only {A lvl C} (t : triple A lvl only C) :
  { rt : left_right_triple A lvl right C | lr_triple_seq rt = triple_seq t } :=
right_of_only (Triple G (Only_end s) Empty) with buffer.has7 s => {
  | ? inl v := ? Not_enough v;
  | ? inr s1 with buffer.pop2 s1 => {
    | ? (a1, a2, s2) with buffer.pair a1 a2 => {
      | ? p := ? Ok_lrt (Triple G (Right Ec p s2) Empty) } } };
right_of_only (Triple reg (Only col p s) child) with buffer.pop2 p => {
  | ? (a1, a2, p1) with buffer.pair a1 a2, push_ne_chain (Small p1) child => {
    | ? p2, ? child1 :=
      ? Ok_lrt (Triple reg (Right col p2 s) child1) } }.

(* Takes a suffix of at least one element, a right prefix, a child chain and a
   right suffix, and returns a stored triple and a left suffix. *)
Equations make_stored_suffix {A lvl ql q ck Cl Cr}
  (sl : suffix A lvl (1 + ql))
  (p : prefix A lvl 2)
  (child : chain A (S lvl) ck only Cl Cr)
  (s : suffix A lvl (5 + q)) :
  { '(stored, sleft) : stored A (S lvl) * suffix A lvl 2 |
    stored_seq stored ++ suffix_seq sleft =
    suffix_seq sl ++ prefix_seq p ++ chain_seq child ++ suffix_seq s } :=
make_stored_suffix sl p child s with buffer.two p, buffer.eject2 s => {
  | ? (a1, a2), ? (sstored, c, d)
    with buffer.inject2 sl a1 a2, buffer.pair c d => {
      | ? pstored, ? sleft := ? (Big pstored child sstored, sleft) } }.

(* Takes a left prefix, a child chain, a left suffix and a prefix of at least
   one elements, and returns a right prefix and a stored. *)
Equations make_prefix_stored {A lvl q qr ck Cl Cr}
  (p : prefix A lvl (5 + q))
  (child : chain A (S lvl) ck only Cl Cr)
  (s : suffix A lvl 2)
  (pr : prefix A lvl (1 + qr)) :
  { '(pright, stored) : prefix A lvl 2 * stored A (S lvl) |
    prefix_seq pright ++ stored_seq stored =
    prefix_seq p ++ chain_seq child ++ suffix_seq s ++ prefix_seq pr } :=
make_prefix_stored p child s pr with buffer.pop2 p, buffer.two s => {
  | ? (a1, a2, pstored), ? (c, d)
    with buffer.pair a1 a2, buffer.push2 c d pr => {
      | ? pright, ? sstored := ? (pright, Big pstored child sstored) } }.

(* Takes a suffix of at least one element and a right triple and returns a
   stored triple and a left suffix. *)
Equations stored_of_right {A lvl ql C}
  (sl : suffix A lvl (1 + ql))
  (tr : triple A lvl right C) :
  { '(stored, sleft) : stored A (S lvl) * suffix A lvl 2 |
    stored_seq stored ++ suffix_seq sleft =
    suffix_seq sl ++ triple_seq tr } :=
stored_of_right sl (Triple G (Right Ec p s) Empty)
  with make_stored_suffix sl p Empty s => { | ? (st, s1) := ? (st, s1) };
stored_of_right sl (Triple reg (Right col p s) child)
  with make_stored_suffix sl p child s => { | ? (st, s1) := ? (st, s1) }.

(* Takes a left triple and a prefix of at least one element and returns a
   right prefix and a stored triple. *)
Equations stored_of_left {A lvl qr C}
  (tl : triple A lvl left C)
  (pr : prefix A lvl (1 + qr)) :
  { '(pright, stored) : prefix A lvl 2 * stored A (S lvl) |
    prefix_seq pright ++ stored_seq stored =
    triple_seq tl ++ prefix_seq pr } :=
stored_of_left (Triple G (Left Ec p s) Empty) pr
  with make_prefix_stored p Empty s pr => { | ? (p1, st) := ? (p1, st) };
stored_of_left (Triple _ (Left _ p s) child) pr
  with make_prefix_stored p child s pr => { | ? (p1, st) := ? (p1, st) }.

(* Makes a left triple out of a pair of left and right triples. *)
Equations left_of_pair {A lvl Cl Cr}
  (tl : triple A lvl left Cl) (tr : triple A lvl right Cr) :
  { tl' : triple A lvl left Cl |
    triple_seq tl' = triple_seq tl ++ triple_seq tr } :=
left_of_pair (Triple G (Left Ec p s) Empty) tr with buffer.pop s => {
  | ? (a1, s1) with buffer.inject p a1, stored_of_right s1 tr => {
    | ? p1, ? (stored, s2) with single_chain stored => {
      | ? child := ? Triple OS (Left Oc p1 s2) child } } };
left_of_pair (Triple reg (Left col p s) child) tr
  with stored_of_right s tr => {
    | ? (stored, s1) with inject_ne_chain child stored => {
      | ? child1 := ? Triple reg (Left col p s1) child1 } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Makes a right triple out of a pair of left and right triples. *)
Equations right_of_pair {A lvl Cl Cr}
  (tl : triple A lvl left Cl) (tr : triple A lvl right Cr) :
  { tr' : triple A lvl right Cr |
    triple_seq tr' = triple_seq tl ++ triple_seq tr } :=
right_of_pair tl (Triple G (Right Ec p s) Empty) with buffer.eject p => {
  | ? (p1, a1) with buffer.push a1 s, stored_of_left tl p1 => {
    | ? s1, ? (p2, stored) with single_chain stored => {
      | ? child := ? Triple OS (Right Oc p2 s1) child } } };
right_of_pair tl (Triple reg (Right col p s) child)
  with stored_of_left tl p => {
    | ? (p1, stored) with push_ne_chain stored child => {
      | ? child1 := ? Triple reg (Right col p1 s) child1 } }.

(* Makes a left [left_right_triple] out of a chain. *)
Equations make_left {A lvl ck Cl Cr} (c : chain A lvl ck only Cl Cr) :
  { t : left_right_triple A lvl left Cl | lr_triple_seq t = chain_seq c } :=
make_left Empty := ? Not_enough V0;
make_left (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with left_of_only t => { | ? t' := ? t' } };
make_left (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with left_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Makes a right [left_right_triple] out of a chain. *)
Equations make_right {A lvl ck Cl Cr} (c : chain A lvl ck only Cl Cr) :
  { t : left_right_triple A lvl right Cr | lr_triple_seq t = chain_seq c } :=
make_right Empty := ? Not_enough V0;
make_right (Single r pkt c) with triple_of_chain (Single r pkt c) => {
  | ? t with right_of_only t => { | ? t' := ? t' } };
make_right (Pair cl cr) with triple_of_chain cl, triple_of_chain cr => {
  | ? tl, ? tr with right_of_pair tl tr => { | ? t := ? Ok_lrt t } }.

(* Concatenates two semi-regular cadeques. *)
Equations semi_concat {A lvl} (s1 s2 : semi_cadeque A lvl) :
  { s3 : semi_cadeque A lvl |
    semi_cadeque_seq s3 = semi_cadeque_seq s1 ++ semi_cadeque_seq s2 } :=
semi_concat (Semi c1) (Semi c2) with make_left c1 => {
  | ? Not_enough v with push_vector v (Semi c2) => {
    | ? c3 := ? c3 };
  | ? Ok_lrt tl with make_right c2 => {
    | ? Not_enough v with inject_vector (Semi c1) v => {
      | ? c3 := ? c3 };
    | ? Ok_lrt tr with chain_of_triple tl, chain_of_triple tr => {
      | ? cl, ? cr := ? Semi (Pair cl cr) } } }.

(* Returns the orange regularity rule required according to the following
   chain, i.e. if it is an only chain or a pair chain. *)
Equations orange {A lvl ck Cr} :
  chain A lvl (S ck) only green Cr ->
  regularity orange Cr (S ck) green Cr :=
orange (Single _ _ _) := OS;
orange (Pair _ _)     := OP.

(* Pops from a green left triple. *)
Equations pop_left_green {A lvl} (tl : triple A lvl left green) :
  { '(a1, pt) : stored A lvl * partial_triple A lvl pair left |
    triple_seq tl = stored_seq a1 ++ pt_triple_seq pt } :=
pop_left_green (Triple G (Left Ec p s) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has5 p1 => {
    | ? inl (a2, a3, a4, a5) with buffer.two s => {
      | ? (a6, a7) := ? (a1, Six_elements (a2, a3, a4, a5, a6, a7)) };
    | ? inr p2 => ? (a1, Ok_pt (Triple G (Left Ec p2 s) Empty)) } };
pop_left_green (Triple G (Left Gc p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Y (Left Yc p1 s) child)) };
pop_left_green (Triple Y (Left Yc p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple (orange child) (Left Oc p1 s) child)) };
pop_left_green (Triple OS (Left Oc p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple R (Left Rc p1 s) child)) };
pop_left_green (Triple OP (Left Oc p s) child)
  with buffer.pop p => { | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple R (Left Rc p1 s) child)) }.

(* Ejects from a green right triple. *)
Equations eject_right_green {A lvl} (tr : triple A lvl right green) :
  { '(pt, a1) : partial_triple A lvl pair right * stored A lvl |
    triple_seq tr = pt_triple_seq pt ++ stored_seq a1 } :=
eject_right_green (Triple G (Right Ec p s) Empty) with buffer.eject s => {
  | ? (s1, a1) with buffer.has5 s1 => {
    | ? inl (a5, a4, a3, a2) with buffer.two p => {
      | ? (a7, a6) := ? (Six_elements (a7, a6, a5, a4, a3, a2), a1) };
    | ? inr s2 => ? (Ok_pt (Triple G (Right Ec p s2) Empty), a1) } };
eject_right_green (Triple G (Right Gc p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Y (Right Yc p s1) child), a1) };
eject_right_green (Triple Y (Right Yc p s) child)
  with buffer.eject s => { | ? (s1, a1) :=
    ? (Ok_pt (Triple (orange child) (Right Oc p s1) child), a1) };
eject_right_green (Triple OS (Right Oc p s) child)
  with buffer.eject s => { | ? (s1, a1) :=
    ? (Ok_pt (Triple R (Right Rc p s1) child), a1) };
eject_right_green (Triple OP (Right Oc p s) child)
  with buffer.eject s => { | ? (s1, a1) :=
    ? (Ok_pt (Triple R (Right Rc p s1) child), a1) }.

(* Pops from an green only triple. *)
Equations pop_only_green {A lvl} (t : triple A lvl only green) :
  { '(a1, pt) : stored A lvl * partial_triple A lvl single only |
    triple_seq t = stored_seq a1 ++ pt_triple_seq pt } :=
pop_only_green (Triple G (Only_end p) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has1 p1 => {
    | ? None := ? (a1, Zero_element);
    | ? Some p2 := ? (a1, Ok_pt (Triple G (Only_end p2) Empty)) } };
pop_only_green (Triple G (Only Gc p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple Y (Only Yc p1 s) child)) };
pop_only_green (Triple Y (Only Yc p s) child) with buffer.pop p => {
  | ? (a1, p1) :=
    ? (a1, Ok_pt (Triple (orange child) (Only Oc p1 s) child)) };
pop_only_green (Triple OS (Only Oc p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple R (Only Rc p1 s) child)) };
pop_only_green (Triple OP (Only Oc p s) child) with buffer.pop p => {
  | ? (a1, p1) := ? (a1, Ok_pt (Triple R (Only Rc p1 s) child)) }.

(* Ejects from an green only triple. *)
Equations eject_only_green {A lvl} (t : triple A lvl only green) :
  { '(pt, a1) : partial_triple A lvl single only * stored A lvl |
    triple_seq t = pt_triple_seq pt ++ stored_seq a1 } :=
eject_only_green (Triple G (Only_end s) Empty) with buffer.eject s => {
  | ? (s1, a1) with buffer.has1 s1 => {
    | ? None := ? (Zero_element, a1);
    | ? Some s2 := ? (Ok_pt (Triple G (Only_end s2) Empty), a1) } };
eject_only_green (Triple G (Only Gc p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple Y (Only Yc p s1) child), a1) };
eject_only_green (Triple Y (Only Yc p s) child) with buffer.eject s => {
  | ? (s1, a1) :=
    ? (Ok_pt (Triple (orange child) (Only Oc p s1) child), a1) };
eject_only_green (Triple OS (Only Oc p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple R (Only Rc p s1) child), a1) };
eject_only_green (Triple OP (Only Oc p s) child) with buffer.eject s => {
  | ? (s1, a1) := ? (Ok_pt (Triple R (Only Rc p s1) child), a1) }.

(* Takes an green only triple and represent it as a sandwich. *)
Equations sandwich_only_green {A lvl} (t : triple A lvl only green) :
  { s : sandwich (stored A lvl) (partial_triple A lvl single only) |
    triple_seq t = sandwich_seq stored_seq pt_triple_seq s } :=
sandwich_only_green (Triple G (Only_end p) Empty) with buffer.pop p => {
  | ? (a1, p1) with buffer.has1 p1 => {
    | ? None := ? Alone a1;
    | ? Some s with buffer.eject s => {
      | ? (s1, z1) with buffer.has1 s1 => {
        | ? None := ? Sandwich a1 Zero_element z1;
        | ? Some b := ? Sandwich a1 (Ok_pt (Triple G (Only_end b) Empty)) z1 } } } };
sandwich_only_green (Triple G (Only Gc p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple Y (Only Yc p1 s1) child)) z1 };
sandwich_only_green (Triple Y (Only Yc p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1
               (Ok_pt (Triple (orange child) (Only Oc p1 s1) child))
               z1 };
sandwich_only_green (Triple OS (Only Oc p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple R (Only Rc p1 s1) child)) z1 };
sandwich_only_green (Triple OP (Only Oc p s) child)
  with buffer.pop p, buffer.eject s => { | ? (a1, p1), ? (s1, z1) :=
    ? Sandwich a1 (Ok_pt (Triple R (Only Rc p1 s1) child)) z1 }.

(* Adapts a coloring to a prefix of 8 or more elements. *)
Equations adapt_to_prefix {qp qs q nc C} :
  coloring qp qs nc C -> coloring (3 + q) qs nc C :=
adapt_to_prefix Gc := Gc;
adapt_to_prefix Yc := Yc;
adapt_to_prefix Oc := Oc;
adapt_to_prefix Rc := Rc;
adapt_to_prefix Ec := Ec.

(* Makes an only triple out of six elements and a right triple. *)
Equations only_of_right {A lvl C}
  (six : six_stored A lvl)
  (tr : triple A lvl right C) :
  { t : triple A lvl only C |
    triple_seq t = six_stored_seq six ++ triple_seq tr } :=
only_of_right (a1, a2, a3, a4, a5, a6) (Triple G (Right Ec p s) Empty)
  with buffer.two p => {
    | ? (a7, a8) with buffer.push2 a7 a8 s => {
      | ? s1 with buffer.push6 a1 a2 a3 a4 a5 a6 s1 => {
        | ? s2 := ? Triple G (Only_end s2) Empty } } };
only_of_right (a1, a2, a3, a4, a5, a6) (Triple reg (Right col p s) child)
  with buffer.push6 a1 a2 a3 a4 a5 a6 p => {
    | ? p1 := ? Triple reg (Only (adapt_to_prefix col) p1 s) child }.

(* Adapts a coloring to a suffix of 8 or more elements. *)
Equations adapt_to_suffix {qp qs q nc C} :
  coloring qp qs nc C -> coloring qp (3 + q) nc C :=
adapt_to_suffix Gc := Gc;
adapt_to_suffix Yc := Yc;
adapt_to_suffix Oc := Oc;
adapt_to_suffix Rc := Rc;
adapt_to_suffix Ec := Ec.

(* Makes an only triple out of a left triple and six elements. *)
Equations only_of_left {A lvl C}
  (tl : triple A lvl left C)
  (six : six_stored A lvl) :
  { t : triple A lvl only C |
    triple_seq t = triple_seq tl ++ six_stored_seq six } :=
only_of_left (Triple G (Left Ec p s) Empty) (a6, a5, a4, a3, a2, a1)
  with buffer.two s => {
    | ? (a8, a7) with buffer.inject2 p a8 a7 => {
      | ? p1 with buffer.inject6 p1 a6 a5 a4 a3 a2 a1 => {
        | ? p2 := ? Triple G (Only_end p2) Empty } } };
only_of_left (Triple reg (Left col p s) child) (a6, a5, a4, a3, a2, a1)
  with buffer.inject6 s a6 a5 a4 a3 a2 a1 => {
    | ? s1 := ? Triple reg (Only (adapt_to_suffix col) p s1) child }.

(* Pops from a green pair chain. *)
Equations pop_pair_green {A lvl}
  (c : chain A lvl pair only green green) :
  { '(a1, sd) : stored A lvl * semi_cadeque A lvl |
    chain_seq c = stored_seq a1 ++ semi_cadeque_seq sd } :=
pop_pair_green (Pair cl cr) with triple_of_chain cl => {
  | ? tl with pop_left_green tl => {
    | ? (a1, Six_elements six) with triple_of_chain cr => {
      | ? tr with only_of_right six tr => {
        | ? t with chain_of_triple t => {
          | ? c := ? (a1, Semi c) } } };
    | ? (a1, Ok_pt tl1) with chain_of_triple tl1 => {
      | ? cl1 := ? (a1, Semi (Pair cl1 cr)) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Ejects from a green pair chain. *)
Equations eject_pair_green {A lvl}
  (c : chain A lvl pair only green green) :
  { '(sd, a1) : semi_cadeque A lvl * stored A lvl |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq a1 } :=
eject_pair_green (Pair cl cr) with triple_of_chain cr => {
  | ? tr with eject_right_green tr => {
    | ? (Six_elements six, a1) with triple_of_chain cl => {
      | ? tl with only_of_left tl six => {
        | ? t with chain_of_triple t => {
          | ? c := ? (Semi c, a1) } } };
    | ? (Ok_pt tr1, a1) with chain_of_triple tr1 => {
      | ? cr1 := ? (Semi (Pair cl cr1), a1) } } }.

(* Takes a green pair chain and represent it as a sandwich. *)
Equations sandwich_pair_green {A lvl}
  (c : chain A lvl pair only green green) :
  { s : sandwich (stored A lvl) (semi_cadeque A lvl) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_pair_green (Pair cl cr)
  with triple_of_chain cl, triple_of_chain cr => {
    | ? tl, ? tr with pop_left_green tl, eject_right_green tr => {
      | ? (a1, Six_elements (a2, a3, a4, a5, a6, a7)),
        ? (Six_elements (z7, z6, z5, z4, z3, z2), z1) with buffer.empty => {
        | ? b with buffer.push6 a2 a3 a4 a5 a6 a7 b => {
          | ? b1 with buffer.inject6 b1 z7 z6 z5 z4 z3 z2 => { | ? b2 :=
            ? Sandwich
              a1
              (Semi (Single G (Packet Hole (Only_end b2)) Empty))
              z1 } } };
      | ? (a1, Six_elements six), ? (Ok_pt tr1, z1)
        with only_of_right six tr1 => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Six_elements six, z1)
        with only_of_left tl1 six => {
          | ? t with chain_of_triple t => {
            | ? c := ? Sandwich a1 (Semi c) z1 } };
      | ? (a1, Ok_pt tl1), ? (Ok_pt tr1, z1)
        with chain_of_triple tl1, chain_of_triple tr1 => {
          | ? cl1, ? cr1 :=
            ? Sandwich a1 (Semi (Pair cl1 cr1)) z1 } } }.

(* Pops from a non-empty green chain. *)
Equations pop_green {A lvl ck} (c : chain A lvl (S ck) only green green) :
  { '(a1, sd) : stored A lvl * semi_cadeque A lvl |
    chain_seq c = stored_seq a1 ++ semi_cadeque_seq sd } :=
pop_green (ck := 0) c with triple_of_chain c => {
  | ? t with pop_only_green t => {
    | ? (a1, Zero_element) := ? (a1, Semi Empty)
    | ? (a1, Ok_pt t1) with chain_of_triple t1 => {
      | ? c1 := ? (a1, Semi c1) } } };
pop_green (ck := 1) c with pop_pair_green c => {
  | ? (a1, sd) := ? (a1, sd) }.

(* Ejects from a non-empty green chain. *)
Equations eject_green {A lvl ck} (c : chain A lvl (S ck) only green green) :
  { '(sd, a1) : semi_cadeque A lvl * stored A lvl |
    chain_seq c = semi_cadeque_seq sd ++ stored_seq a1 } :=
eject_green (ck := 0) c with triple_of_chain c => {
  | ? t with eject_only_green t => {
    | ? (Zero_element, a1) := ? (Semi Empty, a1);
    | ? (Ok_pt t1, a1) with chain_of_triple t1 => {
      | ? c1 := ? (Semi c1, a1) } } };
eject_green (ck := 1) c with eject_pair_green c => {
  | ? (sd, a1) := ? (sd, a1) }.

(* Takes a non-empty green chain and represent it as a sandwich. *)
Equations sandwich_green {A lvl ck}
  (c : chain A lvl (S ck) only green green) :
  { s : sandwich (stored A lvl) (semi_cadeque A lvl) |
    chain_seq c = sandwich_seq stored_seq semi_cadeque_seq s } :=
sandwich_green (ck := 0) c with triple_of_chain c => {
  | ? t with sandwich_only_green t => {
    | ? Alone a1 := ? Alone a1;
    | ? Sandwich a1 Zero_element z1 := ? Sandwich a1 (Semi Empty) z1;
    | ? Sandwich a1 (Ok_pt t1) z1 with chain_of_triple t1 => {
      | ? c1 := ? Sandwich a1 (Semi c1) z1 } } };
sandwich_green (ck := 1) c with sandwich_pair_green c => { | ? res := ? res }.

(* Takes a prefix of at least 5 elements, a prefix of at least 3 elements and
   and a semi-regular cadeque of stored triples. Rearranges the elements of the
   second prefix to make the first one green (i.e. at least 8 elements). *)
Equations make_green_prefix {A lvl q qstored}
  (p : prefix A lvl (5 + q))
  (pstored : prefix A lvl (3 + qstored))
  (child : semi_cadeque A (S lvl)) :
  { '(pgreen, child') : green_buffer A lvl * semi_cadeque A (S lvl) |
    green_buffer_seq pgreen ++ semi_cadeque_seq child' =
    prefix_seq p ++ prefix_seq pstored ++ semi_cadeque_seq child } :=
make_green_prefix p pstored child with buffer.has3p pstored => {
  | ? ((a1, a2, a3), inl v) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with buffer.inject_vector pgreen v => {
      | ? pgreen1 := ? (Gbuf pgreen1, child) } };
  | ? ((a1, a2, a3), inr pstored1) with buffer.inject3 p a1 a2 a3 => {
    | ? pgreen with semi_push (Small pstored1) child => {
      | ? child1 := ? (Gbuf pgreen, child1) } } }.

(* Takes a semi-regular cadeque of stored triples, a suffix of at least 3
   elements and a suffix of at least 5 elements. Rearranges the elements of
   the first suffix to make the second one green (i.e. at least 8 elements). *)
Equations make_green_suffix {A lvl q qstored}
  (child : semi_cadeque A (S lvl))
  (sstored : suffix A lvl (3 + qstored))
  (s : suffix A lvl (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S lvl) * green_buffer A lvl |
    semi_cadeque_seq child' ++ green_buffer_seq sgreen =
    semi_cadeque_seq child ++ suffix_seq sstored ++ suffix_seq s } :=
make_green_suffix child sstored s with buffer.has3s sstored => {
  | ? (inl v, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with buffer.push_vector v sgreen => {
      | ? sgreen1 := ? (child, Gbuf sgreen1) } };
  | ? (inr sstored1, (a3, a2, a1)) with buffer.push3 a3 a2 a1 s => {
    | ? sgreen with semi_inject child (Small sstored1) => {
      | ? child1 := ? (child1, Gbuf sgreen) } } }.

(* Takes a stored triple and a semi-regular cadeque of stored triples. Extracts
   the prefix of the stored triple, the remaining elements and the semi
   regular cadeque form a new semi-regular cadeque. *)
Equations extract_prefix {A lvl}
  (stored : stored A (S lvl))
  (child : semi_cadeque A (S lvl)) :
  { '(pstored, child') : stored_buffer A lvl * semi_cadeque A (S lvl) |
    stored_buffer_seq pstored ++ semi_cadeque_seq child' =
    stored_seq stored ++ semi_cadeque_seq child } :=
extract_prefix (Small p) child := ? (Sbuf p, child);
extract_prefix (Big p schild s) child with semi_push (Small s) child => {
    | ? child1 with semi_concat (Semi schild) child1 => {
      | ? child2 := ? (Sbuf p, child2) } }.

(* Takes a semi-regular cadeque of stored triples and a stored triple. Extracs
   the suffix of the stored triple, the semi-regular cadeque and the remaining
   elements form a new semi-regular cadeque. *)
Equations extract_suffix {A lvl}
  (child : semi_cadeque A (S lvl))
  (stored : stored A (S lvl)) :
  { '(child', sstored) : semi_cadeque A (S lvl) * stored_buffer A lvl |
    semi_cadeque_seq child' ++ stored_buffer_seq sstored =
    semi_cadeque_seq child ++ stored_seq stored } :=
extract_suffix child (Small s) := ? (child, Sbuf s);
extract_suffix child (Big p schild s) with semi_inject child (Small p) => {
  | ? child1 with semi_concat child1 (Semi schild) => {
    | ? child2 := ? (child2, Sbuf s) } }.

(* Takes a prefix of at least 5 elements and a semi-regular cadeque of stored
   triples. Rearranges elements of the semi-regular cadeque to make the prefix
   green. *)
Equations ensure_green_prefix {A lvl q ck}
  (p : prefix A lvl (5 + q))
  (child : chain A (S lvl) (S ck) only green green) :
  { '(pgreen, child') : green_buffer A lvl * semi_cadeque A (S lvl) |
    prefix_seq p ++ chain_seq child =
    green_buffer_seq pgreen ++ semi_cadeque_seq child' } :=
ensure_green_prefix p child with pop_green child => {
  | ? (stored, child1) with extract_prefix stored child1 => {
    | ? (Sbuf pstored, child2) with make_green_prefix p pstored child2 => {
      | ? (pg, child3) := ? (pg, child3) } } }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, lassoc).

(* Takes a semi-regular cadeque of stored triples and a suffix of at least 5
   elements. Rearranges elements of the semi-regular cadeque to make the suffix
   green. *)
Equations ensure_green_suffix {A lvl q ck}
  (child : chain A (S lvl) (S ck) only green green)
  (s : suffix A lvl (5 + q)) :
  { '(child', sgreen) : semi_cadeque A (S lvl) * green_buffer A lvl |
    chain_seq child ++ suffix_seq s =
    semi_cadeque_seq child' ++ green_buffer_seq sgreen } :=
ensure_green_suffix child s with eject_green child => {
  | ? (child1, stored) with extract_suffix child1 stored => {
    | ? (child2, Sbuf sstored) with make_green_suffix child2 sstored s => {
      | ? (child3, sg) := ? (child3, sg) } } }.

(* Takes a body, a following red left node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_left {A hlvl tlvl hk ck}
  (bd : body A hlvl tlvl hk left)
  (red : node A tlvl (S ck) left red)
  (child : chain A (S tlvl) (S ck) only green green) :
  { c : chain A hlvl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_left bd (Left Rc p s) child
  with ensure_green_prefix p child => {
    | ? (Gbuf p1, Semi Empty) :=
      ? Single G (Packet bd (Left Ec p1 s)) Empty;
    | ? (Gbuf p1, Semi child1) :=
      ? Single G (Packet bd (Left Gc p1 s)) child1 }.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [lassoc] hint databases.

   The [unfold Nat.add] tactic ensures that natural numbers that are equal
   are indeed type checked as equal, some additions interfer with the equality
   otherwise. *)
#[local] Obligation Tactic := try (cbn; unfold Nat.add; hauto db:rlist, rassoc).

(* Takes a body, a following red right node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_right {A hlvl tlvl hk ck}
  (bd : body A hlvl tlvl hk right)
  (red : node A tlvl (S ck) right red)
  (child : chain A (S tlvl) (S ck) only green green) :
  { c : chain A hlvl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_right bd (Right Rc p s) child
  with ensure_green_suffix child s => {
    | ? (Semi Empty, Gbuf s1) :=
      ? Single G (Packet bd (Right Ec p s1)) Empty;
    | ? (Semi child1, Gbuf s1) :=
      ? Single G (Packet bd (Right Gc p s1)) child1 }.

(* Takes a body and a following green triple, and makes a green chain out of
   them. *)
Equations make_green_only {A hlvl tlvl hk qp qs}
  (bd : body A hlvl tlvl hk only)
  (p : prefix A tlvl (8 + qp))
  (child : semi_cadeque A (S tlvl))
  (s : prefix A tlvl (8 + qs)) :
  { c : chain A hlvl single hk green green |
    chain_seq c =
      body_seq bd (prefix_seq p ++ semi_cadeque_seq child ++ suffix_seq s) } :=
make_green_only bd p (Semi Empty) s with buffer.has3p8 s => {
  | ? inl ((a1, a2, a3, a4, a5, a6, a7, a8), v)
    with buffer.inject8 p a1 a2 a3 a4 a5 a6 a7 a8 => {
      | ? p1 with buffer.inject_vector p1 v => {
        | ? p2 :=
          ? Single G (Packet bd (Only_end p2)) Empty } };
  | ? inr (small, s1) with single_chain (Small small) => {
    | ? child :=
      ? Single G (Packet bd (Only Gc p s1)) child } };
make_green_only bd p (Semi child) s :=
  ? Single G (Packet bd (Only Gc p s)) child.
Next Obligation. Qed.

(* Changing the default tactics for obligations to be [idtac].

   [hauto] is not used there because it takes too much time to compute, especially in cases where it cannot prove the result. *)
#[local] Obligation Tactic := idtac.

(* Takes a body, a following red only node and the following green chain,
   and makes a green chain out of them. *)
Equations green_of_red_only {A hlvl tlvl hk ck}
  (bd : body A hlvl tlvl hk only)
  (red : node A tlvl (S ck) only red)
  (child : chain A (S tlvl) (S ck) only green green) :
  { c : chain A hlvl single hk green green |
    chain_seq c = body_seq bd (node_seq red (chain_seq child)) } :=
green_of_red_only bd (Only Rc p s) child
  with buffer.has8 p, buffer.has8 s => {
    | ? inl ((a1, a2, a3, a4, a5), vp),
      ? inl ((z5, z4, z3, z2, z1), vs) with sandwich_green child => {
      | ? Alone (Small b)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp b => {
          | ? b1 with buffer.inject_5vector b1 z5 z4 z3 z2 z1 vs => {
            | ? b2 :=
              ? Single G (Packet bd (Only_end b2)) Empty } };
      | ? Alone (Big p1 child1 s1)
        with buffer.push_5vector a1 a2 a3 a4 a5 vp p1 => {
          | ? p2 with buffer.inject_5vector s1 z5 z4 z3 z2 z1 vs => {
            | ? s2 with make_green_only bd p2 (Semi child1) s2 => {
              | ? res := ? res } } };
      | ? Sandwich storedl child1 storedr
        with extract_prefix storedl child1 => { | ? (Sbuf p1, child2)
          with extract_suffix child2 storedr => { | ? (child3, Sbuf s1)
            with buffer.push_5vector a1 a2 a3 a4 a5 vp p1 => { | ? p2
              with buffer.inject_5vector s1 z5 z4 z3 z2 z1 vs => { | ? s2
                with make_green_only bd p2 child3 s2 => {
                  | ? res := ? res } } } } } };
    | ? inl _, ? inr suf1 with ensure_green_prefix p child => {
      | ? (Gbuf p1, child1) with make_green_only bd p1 child1 suf1 => {
        | ? res := ? res } };
    | ? inr pre1, ? inl _ with ensure_green_suffix child s => {
      | ? (child1, Gbuf s1) with make_green_only bd pre1 child1 s1 => {
        | ? res := ? res } };
    | ? inr p1, ? inr suf :=
      ? Single G (Packet bd (Only Gc p1 suf)) child }.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  unfold Nat.add. hauto db:rlist, rassoc.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hp2 * Hp1 * Hres Hs2 Hs1 Hchild.
  do 2 rewrite buffer.correct_concat_map_seq in *.
  rewrite Hp, Hs, Hres, Hp2, Hs2, Hchild.
  autorewrite with rlist rassoc.
  do 7 f_equal.
  aac_rewrite Hs1. aac_rewrite Hp1.
  aac_reflexivity.
Qed.
Next Obligation.
  cbn.
  intros * Hp * Hs * Hres Hchild.
  do 2 rewrite buffer.correct_concat_map_seq in *.
  rewrite Hres, Hs.
  aac_rewrite <-Hchild.
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  hauto db:rlist, rassoc.
Qed.
Next Obligation.
  hauto db:rlist, rassoc.
Qed.

(* Changing the default tactics for obligations to be [hauto] using the [rlist]
   and [rassoc] hint databases. *)
#[local] Obligation Tactic := try (cbn; hauto db:rlist, rassoc).

(* Takes any chain and makes it green. *)
Equations ensure_green {A lvl ck nk Cl Cr}
  (c : chain A lvl ck nk Cl Cr) :
  { c' : chain A lvl ck nk green green | chain_seq c = chain_seq c' } :=
ensure_green Empty := ? Empty;
ensure_green (Single G pkt c) := ? Single G pkt c;
ensure_green (Single R (Packet bd (Only Rc p s)) c)
  with green_of_red_only bd (Only Rc p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Left Rc p s)) c)
  with green_of_red_left bd (Left Rc p s) c => { | ? c' := ? c' };
ensure_green (Single R (Packet bd (Right Rc p s)) c)
  with green_of_red_right bd (Right Rc p s) c => { | ? c' := ? c' };
ensure_green (Pair cl cr) with ensure_green cl, ensure_green cr => {
  | ? cl', ? cr' := ? Pair cl' cr' }.

(* Regularizes a semi-regular cadeque. *)
Equations regularize {A} (sd : semi_cadeque A 0) :
  { d : cadeque A | cadeque_seq d = semi_cadeque_seq sd } :=
regularize (Semi c) with ensure_green c => { | ? c' := ? T c' }.
